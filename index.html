<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Chaos Arena v30.5: Sword & Grenade</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; color: #00ffff; user-select: none; }
        #menu { position: fixed; inset: 0; background: radial-gradient(circle at 15% 50%, #051a2a 0%, #000 100%); display: flex; flex-direction: column; align-items: flex-start; justify-content: center; padding-left: 80px; z-index: 2000; }
        .menu-title { font-size: 50px; letter-spacing: 10px; text-shadow: 0 0 25px #00ffff; margin-bottom: 40px; }
        .btn-list { display: flex; flex-direction: column; gap: 15px; }
        .btn { background: rgba(0,20,30,0.8); color: #008888; border: 2px solid #004444; padding: 15px 40px; font-size: 18px; cursor: pointer; transition: 0.3s; text-align: left; min-width: 250px; clip-path: polygon(0% 0%, 90% 0%, 100% 100%, 0% 100%); }
        .btn:hover { color: #00ffff; border-color: #00ffff; transform: translateX(10px); }
        .btn.selected { background: #00ffff !important; color: #000 !important; }
        #ui { position: fixed; inset: 0; pointer-events: none; z-index: 10; display: none; }
        #hp-bar { width: 350px; height: 12px; background: rgba(255,0,0,0.1); border: 2px solid #00ffff; position: absolute; bottom: 40px; left: 40px; transform: skewX(-25deg); }
        #hp-fill { width: 100%; height: 100%; background: #00ffff; box-shadow: 0 0 15px #00ffff; }
        #minimap { position: absolute; top: 30px; left: 30px; width: 160px; height: 160px; background: rgba(0,5,10,0.9); border: 2px solid #00ffff; }
        #map-canvas { width: 100%; height: 100%; }
        #stats { position: absolute; top: 30px; right: 40px; text-align: right; font-size: 20px; line-height: 1.5; }
        #game-over { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 3000; border: 4px solid #ff0000; }
        .nickname { position: absolute; font-size: 12px; font-weight: bold; text-shadow: 1px 1px 2px #000; pointer-events: none; transform: translate(-50%, -120%); }
        #skill-ui { position: absolute; bottom: 70px; left: 40px; font-size: 14px; }
    </style>
</head>
<body>

<div id="menu">
    <div class="menu-title">CHAOS ARENA</div>
    <div class="btn-list">
        <div id="btn-SOLDIER" class="btn selected" onclick="pickHero('SOLDIER')">UNIT: SOLDIER (GRENADE)</div>
        <div id="btn-TANK" class="btn" onclick="pickHero('TANK')">UNIT: TANK (SWORD)</div>
        <div id="btn-ASSASSIN" class="btn" onclick="pickHero('ASSASSIN')">UNIT: ASSASSIN (DASH)</div>
        <div class="btn" onclick="initGame()" style="margin-top: 30px; color: #00ff00; border-color: #00ff00;">DEPLOY NOW</div>
    </div>
</div>

<div id="game-over">
    <div id="death-score" style="font-size: 40px; color: #f00; margin-bottom: 20px;">MISSION FAILED</div>
    <div style="font-size: 22px; margin-bottom: 30px;">ELIMINATIONS: <span id="final-kills">0</span></div>
    <div class="btn" onclick="location.reload()" style="text-align: center;">RETURN TO BASE</div>
</div>

<div id="ui">
    <div id="minimap"><canvas id="map-canvas" width="160" height="160"></canvas></div>
    <div id="hp-bar"><div id="hp-fill"></div></div>
    <div id="skill-ui">READY TO ENGAGE</div>
    <div id="stats">KILLS: <span id="val-k">0</span> | ALIVE: <span id="val-a">0</span></div>
    <div style="position:fixed; bottom:15px; right:20px; font-size:12px; opacity:0.4;">v30.5 STABLE</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
let scene, camera, renderer, player, clock, mapCtx;
let gameRunning = false, entities = [], bullets = [], buildings = [], vfx = [];
let keys = {}, mouse = { x: 0, y: 0 }, isFiring = false;
let score = 0, zoneRad = 400;
let selHero = 'SOLDIER';

const HERO_DATA = {
    'SOLDIER':  { hp: 200, spd: 0.6, color: 0x00ffff, size: 2.0, skillCD: 8000 },
    'TANK':     { hp: 550, spd: 0.42, color: 0x55ff88, size: 2.8, skillCD: 4000 },
    'ASSASSIN': { hp: 130, spd: 0.85, color: 0xff00ff, size: 1.6, skillCD: 2500 }
};

function pickHero(type) {
    selHero = type;
    document.querySelectorAll('.btn').forEach(b => b.classList.remove('selected'));
    document.getElementById('btn-' + type).classList.add('selected');
}

function initGame() {
    document.getElementById('menu').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    mapCtx = document.getElementById('map-canvas').getContext('2d');
    
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x010408);
    clock = new THREE.Clock();
    
    camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 1, 1500);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const light = new THREE.PointLight(0x00ffff, 1, 1000);
    light.position.set(0, 200, 0);
    scene.add(light);

    const grid = new THREE.GridHelper(1200, 60, 0x00ffff, 0x0a1a1a);
    scene.add(grid);

    zoneMesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 500, 64, 1, true), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.1, side: THREE.DoubleSide }));
    scene.add(zoneMesh);

    // Здания
    for (let i = 0; i < 40; i++) {
        let h = 30 + Math.random()*50;
        const b = new THREE.Mesh(new THREE.BoxGeometry(25, h, 25), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        b.position.set((Math.random()-0.5)*700, h/2, (Math.random()-0.5)*700);
        b.userData.box = new THREE.Box3().setFromObject(b);
        scene.add(b); buildings.push(b);
    }

    player = spawnUnit(selHero, 0, "YOU", true);
    entities.push(player);

    for (let i = 0; i < 24; i++) {
        const t = Object.keys(HERO_DATA)[Math.floor(Math.random()*3)];
        entities.push(spawnUnit(t, i + 1, "BOT", false));
    }

    window.onkeydown = e => keys[e.code] = true;
    window.onkeyup = e => keys[e.code] = false;
    window.onmousemove = e => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    };
    window.onmousedown = () => isFiring = true;
    window.onmouseup = () => isFiring = false;
    
    gameRunning = true;
    loop();
}

function spawnUnit(type, team, name, isPlayer) {
    const d = HERO_DATA[type];
    const g = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(d.size, d.size*2, d.size), new THREE.MeshStandardMaterial({ color: d.color }));
    body.position.y = d.size;
    g.add(body);
    
    // Меч для танка
    let sword = null;
    if(type === 'TANK') {
        sword = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 7), new THREE.MeshBasicMaterial({ color: 0x55ff88, transparent: true, opacity: 0.8 }));
        sword.position.set(2, 2, 3);
        sword.visible = false;
        g.add(sword);
    }

    const label = document.createElement('div');
    label.className = 'nickname';
    label.style.color = isPlayer ? "#00ffff" : "#ff4444";
    document.body.appendChild(label);
    
    g.position.set((Math.random()-0.5)*600, 0, (Math.random()-0.5)*600);
    scene.add(g);
    
    return { mesh: g, body, sword, hp: d.hp, max: d.hp, spd: d.spd, team, label, type, isPlayer, lastAtk: 0, skillCD: 0, isAtk: false };
}

function loop() {
    if (!gameRunning) return;
    requestAnimationFrame(loop);
    const dt = clock.getDelta();
    const now = Date.now();

    zoneRad -= 0.05;
    zoneMesh.scale.set(zoneRad, 1, zoneRad);

    if(player.hp > 0) {
        // Look at mouse
        const ray = new THREE.Raycaster();
        ray.setFromCamera(mouse, camera);
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const pt = new THREE.Vector3();
        if(ray.ray.intersectPlane(plane, pt)) player.mesh.lookAt(pt.x, 0, pt.z);

        // Movement
        const oldPos = player.mesh.position.clone();
        let mv = new THREE.Vector3(0,0,0);
        if (keys['KeyW']) mv.z -= 1; if (keys['KeyS']) mv.z += 1;
        if (keys['KeyA']) mv.x -= 1; if (keys['KeyD']) mv.x += 1;
        player.mesh.position.add(mv.normalize().multiplyScalar(player.spd));
        for (let b of buildings) if (new THREE.Box3().setFromCenterAndSize(player.mesh.position, new THREE.Vector3(3,5,3)).intersectsBox(b.userData.box)) player.mesh.position.copy(oldPos);

        // Combat
        if(isFiring) attack(player);
        if((keys['KeyQ'] || keys['KeyE']) && player.skillCD <= 0) useSkill(player);
        
        // UI Skill
        document.getElementById('skill-ui').innerText = player.skillCD <= 0 ? "SKILL: READY" : "RELOADING: " + (player.skillCD/1000).toFixed(1);
    }

    // Logic
    entities.forEach(ent => {
        if(ent.hp <= 0) return;
        if(ent.skillCD > 0) ent.skillCD -= dt * 1000;

        if(!ent.isPlayer) {
            let target = null; let minDist = 150;
            entities.forEach(o => { if(o !== ent && o.hp > 0 && o.team !== ent.team) { let d = ent.mesh.position.distanceTo(o.mesh.position); if(d < minDist) { minDist = d; target = o; } } });
            if(target) {
                ent.mesh.lookAt(target.mesh.position.x, 0, target.mesh.position.z);
                let stopDist = ent.type === 'TANK' ? 6 : 30;
                if(minDist > stopDist) ent.mesh.translateZ(ent.spd * 0.8);
                if(now - ent.lastAtk > 1500) attack(ent);
                if(ent.skillCD <= 0 && minDist < 50) useSkill(ent);
            }
        }
        if (ent.mesh.position.length() > zoneRad) ent.hp -= 0.4;
    });

    // Bullets / VFX
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        if(b.isGrenade) {
            b.timer -= dt;
            b.mesh.position.add(b.dir.clone().multiplyScalar(b.v));
            b.v *= 0.96;
            if(b.timer <= 0) { explode(b.mesh.position, b.owner); scene.remove(b.mesh); bullets.splice(i, 1); }
        } else {
            b.mesh.position.add(b.dir.clone().multiplyScalar(5));
            let hit = false;
            for(let wall of buildings) if(wall.userData.box.containsPoint(b.mesh.position)) { hit = true; break; }
            entities.forEach(e => {
                if(!hit && e.hp > 0 && e.team !== b.owner.team && b.mesh.position.distanceTo(e.mesh.position) < 4) {
                    e.hp -= 30; hit = true; if(b.owner.isPlayer && e.hp <= 0) score++;
                }
            });
            if(hit || b.mesh.position.length() > 1000) { scene.remove(b.mesh); bullets.splice(i, 1); }
        }
    }

    // VFX Cleanup
    for(let i = vfx.length-1; i>=0; i--) {
        vfx[i].timer -= dt;
        if(vfx[i].type === 'exp') vfx[i].mesh.scale.addScalar(0.4);
        if(vfx[i].timer <= 0) { scene.remove(vfx[i].mesh); vfx.splice(i, 1); }
    }

    // Death Check
    for (let i = entities.length - 1; i >= 0; i--) {
        if (entities[i].hp <= 0) {
            if (entities[i].isPlayer) { gameRunning = false; document.getElementById('game-over').style.display='flex'; document.getElementById('final-kills').innerText = score; }
            entities[i].label.remove(); scene.remove(entities[i].mesh); entities.splice(i, 1);
        }
    }

    camera.position.set(player.mesh.position.x, 110, player.mesh.position.z + 70);
    camera.lookAt(player.mesh.position);
    updateUI();
    renderer.render(scene, camera);
}

function attack(u) {
    const now = Date.now();
    if(now - u.lastAtk < (u.type === 'TANK' ? 600 : 200)) return;
    u.lastAtk = now;

    if(u.type === 'TANK') {
        u.isAtk = true; u.sword.visible = true; u.sword.rotation.y = -1;
        new TWEEN_Manual(u.sword.rotation, {y: 1}, 200, () => { u.sword.visible = false; u.isAtk = false; });
        // Меч наносит урон
        entities.forEach(e => {
            if(e !== u && e.hp > 0 && e.team !== u.team && u.mesh.position.distanceTo(e.mesh.position) < 12) {
                let local = e.mesh.position.clone().applyMatrix4(new THREE.Matrix4().copy(u.mesh.matrixWorld).invert());
                if(local.z > 0) { e.hp -= 80; if(u.isPlayer && e.hp <= 0) score++; }
            }
        });
    } else {
        const b = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: u.isPlayer ? 0x00ffff : 0xff3300 }));
        b.position.copy(u.mesh.position).add(new THREE.Vector3(0, 2.5, 0));
        bullets.push({ mesh: b, dir: new THREE.Vector3(0,0,1).applyQuaternion(u.mesh.quaternion), owner: u, isGrenade: false });
        scene.add(b);
    }
}

function useSkill(u) {
    u.skillCD = HERO_DATA[u.type].skillCD;
    if(u.type === 'SOLDIER') {
        const g = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshStandardMaterial({ color: 0xffaa00 }));
        g.position.copy(u.mesh.position).add(new THREE.Vector3(0, 4, 0));
        bullets.push({ mesh: g, dir: new THREE.Vector3(0,0,1).applyQuaternion(u.mesh.quaternion), owner: u, isGrenade: true, timer: 1.0, v: 2.0 });
        scene.add(g);
    } else if(u.type === 'ASSASSIN') {
        u.mesh.translateZ(25);
    } else if(u.type === 'TANK') {
        u.hp = Math.min(u.max, u.hp + 100); // Танк лечится
    }
}

function explode(pos, owner) {
    const exp = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.6 }));
    exp.position.copy(pos); scene.add(exp);
    vfx.push({ mesh: exp, timer: 0.5, type: 'exp' });
    entities.forEach(e => { if(e.hp > 0 && e.mesh.position.distanceTo(pos) < 25) { e.hp -= 100; if(owner.isPlayer && e.hp <= 0) score++; } });
}

function updateUI() {
    entities.forEach(e => {
        const v = e.mesh.position.clone().add(new THREE.Vector3(0, 8, 0)).project(camera);
        e.label.style.left = `${(v.x * 0.5 + 0.5) * window.innerWidth}px`;
        e.label.style.top = `${(-(v.y * 0.5 - 0.5) * window.innerHeight)}px`;
        e.label.innerText = e.hp > 0 ? (e.isPlayer ? "YOU" : e.type) : "";
    });
    document.getElementById('hp-fill').style.width = (player.hp / player.max * 100) + "%";
    document.getElementById('val-a').innerText = entities.length;
    document.getElementById('val-k').innerText = score;

    mapCtx.clearRect(0,0,160,160);
    entities.forEach(e => {
        mapCtx.fillStyle = e.isPlayer ? "#0ff" : "#f33";
        let mx = 80 + (e.mesh.position.x - player.mesh.position.x) * 0.2;
        let my = 80 + (e.mesh.position.z - player.mesh.position.z) * 0.2;
        mapCtx.fillRect(mx-2, my-2, 4, 4);
    });
}

// Простая функция анимации для меча
function TWEEN_Manual(obj, target, time, cb) {
    let start = Date.now();
    let initial = obj.y;
    let inter = setInterval(() => {
        let elapsed = Date.now() - start;
        let progress = Math.min(elapsed / time, 1);
        obj.y = initial + (target.y - initial) * progress;
        if(progress >= 1) { clearInterval(inter); if(cb) cb(); }
    }, 16);
}
</script>
</body>
</html>
