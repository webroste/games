<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Chaos Arena v29: Engine Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; color: #00ffff; user-select: none; }
        #menu { position: fixed; inset: 0; background: #050a10; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; }
        .row { display: flex; gap: 10px; margin-bottom: 15px; }
        .btn { background: #002222; color: #00ffff; border: 2px solid #00ffff; padding: 12px 20px; cursor: pointer; font-weight: bold; min-width: 120px; text-align: center; }
        .btn.selected { background: #00ffff !important; color: #000 !important; }
        #ui { position: fixed; inset: 0; pointer-events: none; z-index: 10; display: none; }
        #hp-bar { width: 200px; height: 15px; background: #200; border: 2px solid #00ffff; position: absolute; bottom: 20px; left: 20px; }
        #hp-fill { width: 100%; height: 100%; background: #00ffff; }
        #minimap { position: absolute; top: 10px; left: 10px; width: 120px; height: 120px; background: rgba(0,0,0,0.8); border: 1px solid #00ffff; }
        .nickname { position: absolute; font-size: 11px; pointer-events: none; transform: translate(-50%, -100%); white-space: nowrap; }
    </style>
</head>
<body>

<div id="menu">
    <h1 style="text-shadow: 0 0 15px #00ffff;">CHAOS ARENA</h1>
    <div class="row" id="modes">
        <div class="btn selected" onclick="selectBtn(this, 'mode', 1)">SOLO</div>
        <div class="btn" onclick="selectBtn(this, 'mode', 2)">DUO</div>
        <div class="btn" onclick="selectBtn(this, 'mode', 4)">SQUAD</div>
    </div>
    <div class="row" id="heroes">
        <div class="btn selected" onclick="selectBtn(this, 'hero', 'SOLDIER')">SOLDIER</div>
        <div class="btn" onclick="selectBtn(this, 'hero', 'TANK')">TANK</div>
        <div class="btn" onclick="selectBtn(this, 'hero', 'ASSASSIN')">ASSASSIN</div>
    </div>
    <button class="btn" onclick="startGame()" style="margin-top:20px; border-color:#f0f; color:#f0f;">DEPLOY</button>
</div>

<div id="ui">
    <div id="minimap"><canvas id="map-canvas" width="120" height="120"></canvas></div>
    <div id="hp-bar"><div id="hp-fill"></div></div>
    <div style="position: absolute; top: 10px; right: 10px;">ALIVE: <span id="ui-alive">0</span></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
let scene, camera, renderer, player, clock, mapCtx;
let gameActive = false, entities = [], bullets = [], buildings = [], missiles = [];
let keys = {}, score = 0, zoneRadius = 300;
let selMode = 1, selHero = 'SOLDIER';

function selectBtn(el, type, val) {
    el.parentElement.querySelectorAll('.btn').forEach(b => b.classList.remove('selected'));
    el.classList.add('selected');
    if(type === 'mode') selMode = val; else selHero = val;
}

const CONFIG = {
    'SOLDIER':  { hp: 200, spd: 0.6, color: 0x00ffff, size: 1.8 },
    'TANK':     { hp: 450, spd: 0.4, color: 0x00ff88, size: 2.5 },
    'ASSASSIN': { hp: 130, spd: 0.9, color: 0xff00ff, size: 1.5 }
};

function startGame() {
    document.getElementById('menu').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    mapCtx = document.getElementById('map-canvas').getContext('2d');
    init();
}

function init() {
    try {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x02050a);
        clock = new THREE.Clock();
        
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: false }); // Отключено для скорости
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const grid = new THREE.GridHelper(1000, 40, 0x004444, 0x002222);
        scene.add(grid);

        // Зона
        zoneMesh = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 400, 32),
            new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.1, side: THREE.DoubleSide })
        );
        scene.add(zoneMesh);

        // Постройки
        for (let i = 0; i < 35; i++) {
            let h = 20 + Math.random()*30;
            const b = new THREE.Mesh(new THREE.BoxGeometry(16, h, 16), new THREE.MeshLambertMaterial({ color: 0x111111 }));
            b.position.set((Math.random()-0.5)*400, h/2, (Math.random()-0.5)*400);
            b.userData.box = new THREE.Box3().setFromObject(b);
            scene.add(b); buildings.push(b);
        }

        // Игрок
        player = createUnit(selHero, 0, "YOU", true);
        entities.push(player);

        // Боты
        for (let i = 1; i < 20; i++) {
            let team = Math.floor(i / selMode);
            if(selMode > 1 && i < selMode) team = 0;
            const types = Object.keys(CONFIG);
            entities.push(createUnit(types[Math.floor(Math.random()*3)], team, team === 0 ? "ALLY" : "ENEMY", false));
        }

        window.onkeydown = (e) => keys[e.code] = true;
        window.onkeyup = (e) => keys[e.code] = false;
        
        gameActive = true;
        animate();
    } catch(e) { console.error("Init Error:", e); }
}

function createUnit(type, team, name, isPlayer) {
    const d = CONFIG[type];
    const group = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(d.size, d.size*2, d.size), new THREE.MeshLambertMaterial({ color: d.color }));
    body.position.y = d.size;
    group.add(body);
    
    const label = document.createElement('div');
    label.className = 'nickname';
    label.style.color = team === 0 ? "#00ffff" : "#ff4444";
    document.body.appendChild(label);
    
    group.position.set((Math.random()-0.5)*300, 0, (Math.random()-0.5)*300);
    scene.add(group);
    
    return { mesh: group, hp: d.hp, max: d.hp, spd: d.spd, team, name, label, type, isPlayer, lastShot: 0 };
}

function animate() {
    if (!gameActive) return;
    requestAnimationFrame(animate);

    try {
        const now = Date.now();
        zoneRadius -= 0.03;
        zoneMesh.scale.set(zoneRadius, 1, zoneRadius);

        entities.forEach(ent => {
            if (ent.hp <= 0) return;
            const oldPos = ent.mesh.position.clone();

            if (ent.isPlayer) {
                if (keys['KeyW']) ent.mesh.translateZ(ent.spd);
                if (keys['KeyS']) ent.mesh.translateZ(-ent.spd);
                if (keys['KeyA']) ent.mesh.rotation.y += 0.06;
                if (keys['KeyD']) ent.mesh.rotation.y -= 0.06;
                if (keys['Space'] && now - ent.lastShot > 250) { fire(ent); ent.lastShot = now; }
            } else {
                // Простейший ИИ
                let target = null;
                for(let o of entities) {
                    if(o.team !== ent.team && o.hp > 0) {
                        target = o; break; 
                    }
                }
                if(target) {
                    ent.mesh.lookAt(target.mesh.position.x, 0, target.mesh.position.z);
                    ent.mesh.translateZ(ent.spd * 0.8);
                    if(now - ent.lastShot > 800) { fire(ent); ent.lastShot = now; }
                }
            }

            // Коллизии
            let box = new THREE.Box3().setFromCenterAndSize(ent.mesh.position, new THREE.Vector3(2, 4, 2));
            for (let b of buildings) {
                if (box.intersectsBox(b.userData.box)) { ent.mesh.position.copy(oldPos); break; }
            }
            if (ent.mesh.position.length() > zoneRadius) ent.hp -= 0.5;
        });

        // Пули
        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.mesh.position.add(b.dir.clone().multiplyScalar(4));
            let hit = false;
            
            for(let e of entities) {
                if(e.hp > 0 && e.team !== b.owner.team && b.mesh.position.distanceTo(e.mesh.position) < 4) {
                    e.hp -= 25; hit = true; break;
                }
            }
            if(hit || b.mesh.position.length() > 800) { scene.remove(b.mesh); bullets.splice(i, 1); }
        }

        // Смерть
        for (let i = entities.length - 1; i >= 0; i--) {
            if (entities[i].hp <= 0) {
                if (entities[i].isPlayer) { alert("GAME OVER"); location.reload(); return; }
                entities[i].label.remove();
                scene.remove(entities[i].mesh);
                entities.splice(i, 1);
            }
        }

        // Камера
        camera.position.set(player.mesh.position.x, 80, player.mesh.position.z + 60);
        camera.lookAt(player.mesh.position);

        // UI
        entities.forEach(e => {
            const v = e.mesh.position.clone().add(new THREE.Vector3(0, 6, 0)).project(camera);
            e.label.style.left = `${(v.x * 0.5 + 0.5) * window.innerWidth}px`;
            e.label.style.top = `${(-(v.y * 0.5 - 0.5) * window.innerHeight)}px`;
            e.label.innerText = e.hp > 0 ? e.name : "";
        });

        document.getElementById('hp-fill').style.width = (player.hp / player.max * 100) + "%";
        document.getElementById('ui-alive').innerText = entities.length;

        renderer.render(scene, camera);
    } catch(err) {
        console.error("Animation Frame Error:", err);
    }
}

function fire(owner) {
    const bMesh = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshBasicMaterial({ color: owner.team === 0 ? 0x00ffff : 0xff4400 }));
    bMesh.position.copy(owner.mesh.position).add(new THREE.Vector3(0, 2, 0));
    const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(owner.mesh.quaternion);
    bullets.push({ mesh: bMesh, dir, owner });
    scene.add(bMesh);
}
</script>
</body>
</html>
