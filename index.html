<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Chaos Arena v8: Collision & Damage</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: monospace; user-select: none; }
        #ui { position: fixed; inset: 0; pointer-events: none; z-index: 10; color: #0f0; display: none; padding: 20px; }
        
        /* ДЕБАГ КОНСОЛЬ */
        #debug { position: fixed; top: 10px; left: 10px; width: 300px; height: 150px; background: rgba(0,0,0,0.8); 
                 color: #0f0; font-size: 12px; padding: 10px; border: 1px solid #0f0; pointer-events: none; overflow: hidden; }
        
        #hp-bar { width: 300px; height: 25px; background: #300; border: 2px solid #0f0; position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); }
        #hp-fill { width: 100%; height: 100%; background: #0f0; transition: 0.1s; }
        #stats { position: absolute; top: 20px; right: 20px; text-align: right; font-size: 20px; }
        #start-btn { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 40px; 
                     background: #000; color: #0f0; border: 3px solid #0f0; cursor: pointer; font-size: 24px; z-index: 100; }
    </style>
</head>
<body>

<div id="debug">Initializing system...</div>
<button id="start-btn" onclick="startGame()">ЗАПУСТИТЬ ПРОТОКОЛ</button>

<div id="ui">
    <div id="hp-bar"><div id="hp-fill"></div></div>
    <div id="stats">KILLS: <span id="kills">0</span> | ALIVE: <span id="alive">0</span></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
let scene, camera, renderer, player, clock;
let gameActive = false;
let entities = [];
let bullets = [];
let buildings = [];
let keys = {};
let score = 0;

function log(msg) {
    const d = document.getElementById('debug');
    d.innerHTML = "> " + msg + "<br>" + d.innerHTML.split("<br>").slice(0, 8).join("<br>");
}

function startGame() {
    document.getElementById('start-btn').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    init();
}

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020205);
    clock = new THREE.Clock();

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    const l = new THREE.PointLight(0x00ff00, 1, 100);
    l.position.set(0, 20, 0);
    scene.add(l);

    // Сетка
    scene.add(new THREE.GridHelper(400, 40, 0x004400, 0x002200));

    // Постройки с коллизией
    for (let i = 0; i < 25; i++) {
        const h = 8 + Math.random() * 12;
        const w = 5 + Math.random() * 5;
        const geo = new THREE.BoxGeometry(w, h, w);
        const mat = new THREE.MeshStandardMaterial({ color: 0x111111, emissive: 0x001100 });
        const b = new THREE.Mesh(geo, mat);
        
        b.position.set((Math.random()-0.5)*180, h/2, (Math.random()-0.5)*180);
        // Границы для коллизий
        b.userData.box = new THREE.Box3().setFromObject(b);
        scene.add(b);
        buildings.push(b);
    }

    // Игрок
    player = createUnit(0x00aaff, true);
    entities.push(player);

    window.onkeydown = (e) => keys[e.code] = true;
    window.onkeyup = (e) => keys[e.code] = false;

    gameActive = true;
    log("Battle Royale Started");
    animate();
}

function createUnit(color, isPlayer = false) {
    const group = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 1.5), new THREE.MeshStandardMaterial({ color }));
    body.position.y = 1.5;
    group.add(body);
    
    const gun = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 1.2), new THREE.MeshStandardMaterial({ color: 0x333333 }));
    gun.position.set(0.8, 2, 0.8);
    group.add(gun);

    scene.add(group);
    return { mesh: group, hp: 100, isPlayer, lastShot: 0, radius: 1.2, isMoving: false };
}

function checkWallCollision(pos, radius) {
    const pBox = new THREE.Box3().setFromCenterAndSize(pos, new THREE.Vector3(radius, 4, radius));
    for (let b of buildings) {
        if (pBox.intersectsBox(b.userData.box)) return true;
    }
    return false;
}

function spawnBullet(owner) {
    const b = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({ color: owner.isPlayer ? 0x00ffff : 0xff0000 }));
    b.position.copy(owner.mesh.position);
    b.position.y = 2;
    
    const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(owner.mesh.quaternion).normalize();
    bullets.push({ mesh: b, dir: dir, owner: owner });
    scene.add(b);
}

function animate() {
    if (!gameActive) return;
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    const time = clock.getElapsedTime();

    // Авто-спавн ботов
    while (entities.length < 15) {
        const bot = createUnit(0xff3333);
        bot.mesh.position.set((Math.random()-0.5)*180, 0, (Math.random()-0.5)*180);
        if (!checkWallCollision(bot.mesh.position, 2)) entities.push(bot);
        else scene.remove(bot.mesh);
    }

    // Логика игроков и ботов
    entities.forEach(ent => {
        const oldPos = ent.mesh.position.clone();
        
        if (ent.isPlayer) {
            handlePlayerMovement(ent);
        } else {
            updateBotAI(ent);
        }

        // Проверка коллизий со зданиями
        if (checkWallCollision(ent.mesh.position, ent.radius)) {
            ent.mesh.position.copy(oldPos);
        }

        // Анимация дыхания/ходьбы
        ent.mesh.children[0].position.y = 1.5 + (ent.isMoving ? Math.abs(Math.sin(time*10))*0.3 : Math.sin(time*2)*0.05);
    });

    // Физика пуль
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.add(b.dir.clone().multiplyScalar(1.2));

        let removed = false;

        // Попадание в здание
        for (let wall of buildings) {
            if (wall.userData.box.containsPoint(b.mesh.position)) {
                log("Bullet hit wall");
                removed = true; break;
            }
        }

        // Попадание в цель
        if (!removed) {
            for (let j = entities.length - 1; j >= 0; j--) {
                const target = entities[j];
                if (target === b.owner) continue;

                if (b.mesh.position.distanceTo(target.mesh.position.clone().add(new THREE.Vector3(0,1.5,0))) < 1.8) {
                    target.hp -= 20;
                    log((b.owner.isPlayer ? "PLAYER" : "BOT") + " hit target! HP: " + target.hp);
                    removed = true;
                    if (target.hp <= 0) {
                        if (target.isPlayer) { alert("ВЫ ПРОИГРАЛИ!"); location.reload(); }
                        if (b.owner.isPlayer) score++;
                        scene.remove(target.mesh);
                        entities.splice(j, 1);
                    }
                    break;
                }
            }
        }

        if (removed || b.mesh.position.length() > 200) {
            scene.remove(b.mesh);
            bullets.splice(i, 1);
        }
    }

    // UI
    document.getElementById('hp-fill').style.width = player.hp + "%";
    document.getElementById('kills').innerText = score;
    document.getElementById('alive').innerText = entities.length;

    camera.position.lerp(new THREE.Vector3(player.mesh.position.x, 35, player.mesh.position.z + 25), 0.1);
    camera.lookAt(player.mesh.position);
    renderer.render(scene, camera);
}

function handlePlayerMovement(p) {
    p.isMoving = false;
    const s = 0.5;
    if (keys['KeyW']) { p.mesh.translateZ(s); p.isMoving = true; }
    if (keys['KeyS']) { p.mesh.translateZ(-s); p.isMoving = true; }
    if (keys['KeyA']) { p.mesh.rotation.y += 0.05; }
    if (keys['KeyD']) { p.mesh.rotation.y -= 0.05; }
    if (keys['Space'] && Date.now() - p.lastShot > 300) {
        spawnBullet(p);
        p.lastShot = Date.now();
    }
}

function updateBotAI(bot) {
    let closest = null;
    let dMin = 50;
    entities.forEach(other => {
        if (other === bot) return;
        let d = bot.mesh.position.distanceTo(other.mesh.position);
        if (d < dMin) { dMin = d; closest = other; }
    });

    if (closest) {
        bot.mesh.lookAt(closest.mesh.position);
        if (dMin > 15) {
            bot.mesh.translateZ(0.15);
            bot.isMoving = true;
        } else {
            bot.isMoving = false;
            if (Date.now() - bot.lastShot > 1000) {
                spawnBullet(bot);
                bot.lastShot = Date.now();
            }
        }
    } else {
        bot.isMoving = false;
        bot.mesh.rotation.y += 0.01;
    }
}
</script>
</body>
</html>
