<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Chaos Arena v10: Team Modes</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; color: #0f0; user-select: none; }
        
        /* ГЛАВНОЕ МЕНЮ */
        #menu { position: fixed; inset: 0; background: radial-gradient(circle, #051005 0%, #000 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; border: 10px double #0f0; }
        .menu-title { font-size: 50px; text-shadow: 0 0 20px #0f0; margin-bottom: 30px; animation: blink 2s infinite; }
        
        .btn { background: #000; color: #0f0; border: 2px solid #0f0; padding: 15px 40px; font-size: 20px; cursor: pointer; margin: 10px; transition: 0.3s; width: 350px; text-align: center; font-weight: bold; }
        .btn:hover { background: #0f0; color: #000; box-shadow: 0 0 15px #0f0; }
        
        /* КНОПКА РЕЖИМА */
        .btn-mode { border-color: purple; color: purple; }
        .btn-mode:hover { background: purple; color: #fff; box-shadow: 0 0 15px purple; }

        /* ОКНО ВЫБОРА ПЕРСОНАЖА */
        #char-selection { position: fixed; inset: 50px; background: rgba(0,20,0,0.95); border: 3px solid #0f0; display: none; z-index: 1100; padding: 20px; overflow-y: auto; }
        .char-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; margin-top: 20px; }
        .char-item { aspect-ratio: 1; border: 1px solid #0f0; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 12px; transition: 0.2s; }
        .char-item:hover { background: #0f0; color: #000; }

        /* UI ИГРЫ */
        #ui { position: fixed; inset: 0; pointer-events: none; z-index: 10; display: none; padding: 20px; }
        #debug { position: fixed; top: 10px; left: 10px; width: 250px; height: 100px; background: rgba(0,0,0,0.7); font-size: 11px; padding: 5px; border: 1px solid #0f0; }
        #hp-bar { width: 300px; height: 20px; background: #300; border: 2px solid #0f0; position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); }
        #hp-fill { width: 100%; height: 100%; background: #0f0; }
        #zone-timer { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); font-size: 24px; color: #f00; text-shadow: 0 0 10px #f00; }

        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    </style>
</head>
<body>

<div id="debug">System: Waiting for pilot...</div>

<div id="menu">
    <div class="menu-title">CHAOS ARENA V10</div>
    <div class="btn" onclick="startGame()">НАЧАТЬ ВЫСАДКУ</div>
    <div class="btn" onclick="openCharSelect()">ГЕРОЙ: <span id="current-char">ID-1</span></div>
    
    <div class="btn btn-mode" id="btn-mode" onclick="toggleMode()">РЕЖИМ: СОЛО</div>
    
    <p style="font-size: 12px; margin-top: 20px;">[ ОСТОРОЖНО: ЗОНА СУЖАЕТСЯ ]</p>
</div>

<div id="char-selection">
    <h2>ВЫБЕРИТЕ ОПЕРАТИВНИКА</h2>
    <div class="char-grid" id="char-grid"></div>
    <div class="btn" style="margin-top: 30px; width: 150px;" onclick="closeCharSelect()">НАЗАД</div>
</div>

<div id="ui">
    <div id="zone-timer">ЗОНА СУЖАЕТСЯ!</div>
    <div id="hp-bar"><div id="hp-fill"></div></div>
    <div style="position: absolute; top: 20px; right: 20px; text-align: right;">
        KILLS: <span id="kills">0</span><br>
        ALIVE: <span id="alive">0</span>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
let scene, camera, renderer, player, clock;
let gameActive = false;
let entities = [], bullets = [], buildings = [];
let keys = {};
let score = 0;
let playerColor = 0x00aaff;
let zoneMesh, zoneRadius = 150;

// Режимы игры
let gameMode = "SOLO"; // SOLO, DUO, SQUAD
const modes = ["СОЛО", "ДУО", "ОТРЯД"];
let currentModeIndex = 0;

function toggleMode() {
    currentModeIndex = (currentModeIndex + 1) % modes.length;
    document.getElementById('btn-mode').innerText = "РЕЖИМ: " + modes[currentModeIndex];
    gameMode = modes[currentModeIndex];
}

const grid = document.getElementById('char-grid');
for(let i=1; i<=30; i++) {
    const item = document.createElement('div');
    item.className = 'char-item';
    const color = `hsl(${i * 12}, 70%, 50%)`;
    item.style.backgroundColor = color;
    item.innerText = "ID-" + i;
    item.onclick = () => {
        playerColor = color;
        document.getElementById('current-char').innerText = "ID-" + i;
        document.getElementById('current-char').style.color = color;
        closeCharSelect();
    };
    grid.appendChild(item);
}

function openCharSelect() { document.getElementById('char-selection').style.display = 'block'; }
function closeCharSelect() { document.getElementById('char-selection').style.display = 'none'; }

function log(msg) {
    const d = document.getElementById('debug');
    d.innerHTML = "> " + msg + "<br>" + d.innerHTML.split("<br>").slice(0, 5).join("<br>");
}

function startGame() {
    document.getElementById('menu').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    init();
}

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020502);
    clock = new THREE.Clock();

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    scene.add(new THREE.GridHelper(400, 50, 0x00ff00, 0x002200));

    // ЗОНА
    const zoneGeo = new THREE.CylinderGeometry(1, 1, 50, 64, 1, true);
    const zoneMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
    zoneMesh = new THREE.Mesh(zoneGeo, zoneMat);
    zoneMesh.position.y = 25;
    scene.add(zoneMesh);

    // ПОСТРОЙКИ
    for (let i = 0; i < 25; i++) {
        const h = 10 + Math.random() * 15;
        const b = new THREE.Mesh(new THREE.BoxGeometry(6, h, 6), new THREE.MeshStandardMaterial({ color: 0x111111, emissive: 0x001100 }));
        b.position.set((Math.random()-0.5)*200, h/2, (Math.random()-0.5)*200);
        b.userData.box = new THREE.Box3().setFromObject(b);
        scene.add(b);
        buildings.push(b);
    }

    // ИГРОК
    player = createUnit(playerColor, true);
    entities.push(player);

    // ОДНОРАЗОВЫЙ СПАВН БОТОВ ПРИ СТАРТЕ
    log(`Mode: ${gameMode}. Deploying combatants...`);
    for (let i = 0; i < 19; i++) {
        const bot = createUnit(0xff4444);
        let spawned = false;
        while (!spawned) {
            let rx = (Math.random() - 0.5) * 250;
            let rz = (Math.random() - 0.5) * 250;
            bot.mesh.position.set(rx, 0, rz);
            if (!checkWall(bot.mesh.position)) {
                entities.push(bot);
                spawned = true;
            }
        }
    }

    window.onkeydown = (e) => keys[e.code] = true;
    window.onkeyup = (e) => keys[e.code] = false;

    gameActive = true;
    log("Infiltration started...");
    animate();
}

function createUnit(color, isPlayer = false) {
    const group = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 1.5), new THREE.MeshStandardMaterial({ color }));
    body.position.y = 1.5;
    group.add(body);
    
    const gun = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 1.2), new THREE.MeshStandardMaterial({ color: 0x333333 }));
    gun.position.set(0.8, 2.2, 0.8);
    group.add(gun);

    scene.add(group);
    return { mesh: group, hp: 100, isPlayer, lastShot: 0, radius: 1.2, isMoving: false };
}

function spawnBullet(owner) {
    const b = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({ color: owner.isPlayer ? 0x00ffff : 0xff0000 }));
    b.position.copy(owner.mesh.position).add(new THREE.Vector3(0, 2.2, 0));
    const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(owner.mesh.quaternion).normalize();
    bullets.push({ mesh: b, dir: dir, owner: owner });
    scene.add(b);
}

function checkWall(pos) {
    const pBox = new THREE.Box3().setFromCenterAndSize(pos, new THREE.Vector3(1.5, 4, 1.5));
    for (let b of buildings) if (pBox.intersectsBox(b.userData.box)) return true;
    return false;
}

function animate() {
    if (!gameActive) return;
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();

    zoneRadius -= 0.02;
    if(zoneRadius < 5) zoneRadius = 5;
    zoneMesh.scale.set(zoneRadius, 1, zoneRadius);

    entities.forEach(ent => {
        const oldPos = ent.mesh.position.clone();
        if (ent.isPlayer) {
            ent.isMoving = false;
            if (keys['KeyW']) { ent.mesh.translateZ(0.5); ent.isMoving = true; }
            if (keys['KeyS']) { ent.mesh.translateZ(-0.5); ent.isMoving = true; }
            if (keys['KeyA']) ent.mesh.rotation.y += 0.06;
            if (keys['KeyD']) ent.mesh.rotation.y -= 0.06;
            if (keys['Space'] && Date.now() - ent.lastShot > 300) { spawnBullet(ent); ent.lastShot = Date.now(); }
        } else {
            let target = player;
            ent.mesh.lookAt(target.mesh.position);
            ent.mesh.translateZ(0.15);
            ent.isMoving = true;
            if (Date.now() - ent.lastShot > 1500 && ent.mesh.position.distanceTo(player.mesh.position) < 30) {
                spawnBullet(ent); ent.lastShot = Date.now();
            }
        }

        if (checkWall(ent.mesh.position)) ent.mesh.position.copy(oldPos);

        const distToCenter = ent.mesh.position.length();
        if (distToCenter > zoneRadius) {
            ent.hp -= 0.2;
            if(ent.isPlayer) log("WARNING: Outside Safe Zone!");
        }

        ent.mesh.children[0].position.y = 1.5 + (ent.isMoving ? Math.abs(Math.sin(time*10))*0.3 : 0);
    });

    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.add(b.dir.clone().multiplyScalar(1.5));
        let hit = false;

        for (let ent of entities) {
            if (ent === b.owner) continue;
            if (b.mesh.position.distanceTo(ent.mesh.position.clone().add(new THREE.Vector3(0,1.5,0))) < 2) {
                ent.hp -= 25;
                hit = true;
                if (ent.hp <= 0) {
                    if (ent.isPlayer) { alert("Вы погибли!"); location.reload(); }
                    if (b.owner.isPlayer) score++;
                    scene.remove(ent.mesh);
                    entities = entities.filter(e => e !== ent);
                }
                break;
            }
        }
        if (hit || b.mesh.position.length() > 300) { scene.remove(b.mesh); bullets.splice(i, 1); }
    }

    document.getElementById('hp-fill').style.width = player.hp + "%";
    document.getElementById('kills').innerText = score;
    document.getElementById('alive').innerText = entities.length;

    camera.position.lerp(new THREE.Vector3(player.mesh.position.x, 40, player.mesh.position.z + 30), 0.1);
    camera.lookAt(player.mesh.position);
    renderer.render(scene, camera);
}
</script>
</body>
</html>
