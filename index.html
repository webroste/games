<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MLBB: Ultra High Detail Edition</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background: #010409; 
            touch-action: none; font-family: 'Segoe UI', sans-serif; 
            user-select: none; -webkit-user-select: none;
        }

        /* –ö–û–ù–°–û–õ–¨ –†–ê–ó–†–ê–ë–û–¢–ß–ò–ö–ê */
        #debug-panel {
            position: absolute; top: 15px; left: 15px; width: 320px; max-height: 280px;
            background: rgba(1, 4, 9, 0.95); color: #00ffaa; font-family: 'Consolas', monospace; 
            font-size: 11px; padding: 15px; border-radius: 12px; overflow-y: auto; 
            z-index: 9999; display: none; border: 1px solid #30363d;
            box-shadow: 0 15px 40px rgba(0,0,0,0.8); pointer-events: none;
        }
        .log-error { color: #ff6b6b; }
        .log-warn { color: #ffd93d; }
        .log-success { color: #6bff6b; }

        /* –ò–ù–¢–ï–†–§–ï–ô–° */
        .ui-screen { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
        
        #start-menu { 
            background: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)), 
                        radial-gradient(circle at center, #1e3a8a, #010409); 
        }

        .main-title { 
            color: #ffcc00; font-size: 54px; letter-spacing: 12px; font-weight: 900;
            text-shadow: 0 0 40px rgba(255, 204, 0, 0.4); margin-bottom: 60px;
            animation: pulse 3s infinite ease-in-out;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

        .action-btn {
            background: linear-gradient(180deg, #3b82f6, #1d4ed8);
            border: 3px solid #ffcc00; color: #fff; padding: 22px 80px;
            font-size: 24px; font-weight: bold; border-radius: 18px; cursor: pointer;
            text-transform: uppercase; transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 0 #1e3a8a, 0 15px 30px rgba(0,0,0,0.5);
        }
        .action-btn:active { transform: translateY(6px); box-shadow: 0 4px 0 #1e3a8a; }

        /* –ò–ì–†–û–í–û–ô –•–ê–î */
        #game-hud { display: none; pointer-events: none; }

        #minimap-wrap {
            position: absolute; top: 30px; left: 30px; width: 200px; height: 200px;
            background: rgba(13, 17, 23, 0.95); border: 3px solid #30363d;
            border-radius: 20px; overflow: hidden; pointer-events: auto;
            box-shadow: 0 0 25px rgba(0,0,0,0.7);
        }
        #m-canvas { width: 100%; height: 100%; }

        #joystick-outer {
            position: absolute; bottom: 70px; left: 70px; width: 150px; height: 150px;
            background: rgba(255, 255, 255, 0.05); border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%; pointer-events: auto; backdrop-filter: blur(5px);
        }
        #joystick-inner {
            position: absolute; top: 50%; left: 50%; width: 65px; height: 65px;
            background: radial-gradient(circle, #ffffff, #cbd5e1); border-radius: 50%;
            transform: translate(-50%, -50%); box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        #recall-button {
            position: absolute; bottom: 80px; right: 80px; width: 100px; height: 100px;
            background: linear-gradient(135deg, #6366f1, #312e81); border: 4px solid #e0e7ff;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 44px; color: white; pointer-events: auto; cursor: pointer;
            box-shadow: 0 0 40px rgba(99, 102, 241, 0.4); transition: transform 0.1s;
        }
        #recall-button:active { transform: scale(0.8); }

        #recall-status {
            position: absolute; bottom: 250px; width: 100%; text-align: center;
            color: #00f2ff; font-size: 34px; font-weight: 900; display: none;
            text-shadow: 0 0 25px rgba(0, 242, 255, 0.6); letter-spacing: 5px;
        }

        #debug-switch {
            position: absolute; top: 30px; right: 30px; padding: 14px 28px;
            background: rgba(13, 17, 23, 0.8); color: #fff; border: 1px solid #30363d;
            border-radius: 40px; z-index: 10000; cursor: pointer; font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="debug-panel"></div>
    <div id="debug-switch" onclick="toggleDebugger()">CONSOLE [OFF]</div>

    <div id="start-menu" class="ui-screen">
        <div class="main-title">MOBILE LEGENDS</div>
        <button class="action-btn" onclick="launchGame()">Start Match</button>
    </div>

    <div id="game-hud" class="ui-screen">
        <div id="minimap-wrap"><canvas id="m-canvas"></canvas></div>
        <div id="joystick-outer"><div id="joystick-inner"></div></div>
        <div id="recall-status">RECALLING... <span id="r-time">5</span></div>
        <div id="recall-button">üè†</div>
        <div id="camera-track" style="position:absolute; right:0; top:0; width:60%; height:100%; pointer-events:auto;"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        /**
         * GLOBAL CONFIGURATION
         */
        let scene, camera, renderer, hero, recallRing;
        let staticObjects = [], worldDecor = [];
        let moving = false, dir = { x: 0, z: 0 };
        let isRecalling = false, rInterval;
        let camOffset = { x: 0, z: 0 };
        let debugMode = false;

        const WORLD_SCALE = 800;
        const COLOR_BLUE = 0x2563eb;
        const COLOR_RED = 0xdc2626;

        /**
         * DEBUGGER CORE
         */
        function gameLog(text, mode = 'info') {
            console.log(`%c[GAME] ${text}`, 'color: #00ffaa');
            if(!debugMode) return;
            const box = document.getElementById('debug-panel');
            const div = document.createElement('div');
            div.className = mode === 'error' ? 'log-error' : (mode === 'warn' ? 'log-warn' : 'log-success');
            div.innerHTML = `&gt; [${new Date().toLocaleTimeString().split(' ')[0]}] ${text}`;
            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
        }

        function toggleDebugger() {
            debugMode = !debugMode;
            document.getElementById('debug-panel').style.display = debugMode ? 'block' : 'none';
            document.getElementById('debug-switch').innerText = `CONSOLE [${debugMode ? 'ON' : 'OFF'}]`;
            gameLog("System diagnostics toggled");
        }

        /**
         * GAME INITIALIZATION
         */
        function launchGame() {
            gameLog("Initializing 3D Environment...", "success");
            document.getElementById('start-menu').style.display = 'none';
            document.getElementById('game-hud').style.display = 'block';
            
            initEngine();
        }

        function initEngine() {
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x010409);
                scene.fog = new THREE.Fog(0x010409, 60, 250);

                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
                
                renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.body.appendChild(renderer.domElement);

                // Lighting System
                const amb = new THREE.AmbientLight(0xffffff, 0.45);
                scene.add(amb);

                const sun = new THREE.DirectionalLight(0xffffff, 1.4);
                sun.position.set(150, 250, 150);
                scene.add(sun);

                // Build Systems
                createLandscape();
                generateBases();
                placeTowerNetwork();
                populateJungle();
                initHero();
                bindControls();
                
                gameLog("Map generation completed. Units ready.", "success");
                renderLoop();
            } catch (err) {
                gameLog("Engine failure: " + err.message, "error");
            }
        }

        /**
         * MAP ARCHITECTURE
         */
        function createLandscape() {
            // Main Battlefield
            const gGeo = new THREE.PlaneGeometry(WORLD_SCALE, WORLD_SCALE, 32, 32);
            const gMat = new THREE.MeshStandardMaterial({ color: 0x064e3b, roughness: 1 });
            const ground = new THREE.Mesh(gGeo, gMat);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // The River
            const rMat = new THREE.MeshStandardMaterial({ 
                color: 0x075985, 
                transparent: true, 
                opacity: 0.7, 
                emissive: 0x0c4a6e 
            });
            const river = new THREE.Mesh(new THREE.PlaneGeometry(100, WORLD_SCALE), rMat);
            river.rotation.x = -Math.PI / 2;
            river.position.y = 0.1;
            scene.add(river);

            // River Bases (Lord & Turtle)
            createRiverArena(0, 120); // Top Pit
            createRiverArena(0, -120); // Bottom Pit

            // Road Infrastructure
            drawLane(0, 0, Math.PI / 4); // MID
            drawLane(-280, 0, 0); // TOP
            drawLane(280, 0, 0);  // BOT
            drawLane(0, -280, Math.PI / 2); // RED BASE LINE
            drawLane(0, 280, Math.PI / 2);  // BLUE BASE LINE
        }

        function createRiverArena(x, z) {
            const group = new THREE.Group();
            const floor = new THREE.Mesh(
                new THREE.CircleGeometry(40, 32),
                new THREE.MeshStandardMaterial({ color: 0x1e293b })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0.15;
            group.add(floor);

            for(let i=0; i<8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(Math.random()*5 + 5),
                    new THREE.MeshStandardMaterial({ color: 0x334155 })
                );
                rock.position.set(Math.cos(angle)*40, 2, Math.sin(angle)*40);
                group.add(rock);
                staticObjects.push({ x: x + rock.position.x, z: z + rock.position.z, r: 8 });
            }
            group.position.set(x, 0, z);
            scene.add(group);
        }

        function drawLane(x, z, rot) {
            const l = new THREE.Mesh(
                new THREE.PlaneGeometry(55, 1200),
                new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.9 })
            );
            l.rotation.x = -Math.PI / 2;
            l.rotation.z = rot;
            l.position.set(x, 0.12, z);
            scene.add(l);
        }

        function generateBases() {
            spawnBaseComplex(-330, 330, COLOR_BLUE);
            spawnBaseComplex(330, -330, COLOR_RED);
        }

        function spawnBaseComplex(x, z, team) {
            const baseGroup = new THREE.Group();
            
            // Crystal Throne
            const throne = new THREE.Mesh(
                new THREE.IcosahedronGeometry(12, 1),
                new THREE.MeshStandardMaterial({ color: team, emissive: team, emissiveIntensity: 2 })
            );
            throne.position.y = 15;
            baseGroup.add(throne);

            // Defensive Pillars
            for(let i=0; i<4; i++) {
                const pillar = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 25, 6),
                    new THREE.MeshStandardMaterial({ color: 0x0f172a })
                );
                const ang = (i / 4) * Math.PI * 2;
                pillar.position.set(Math.cos(ang)*25, 12.5, Math.sin(ang)*25);
                baseGroup.add(pillar);
            }

            baseGroup.position.set(x, 0, z);
            scene.add(baseGroup);
            staticObjects.push({ x, z, r: 25, team, main: true });
        }

        function placeTowerNetwork() {
            // Blue Side Positions
            const bp = [
                {x: -60, z: 60}, {x: -120, z: 120}, {x: -180, z: 180}, // Mid
                {x: -280, z: 180}, {x: -280, z: 60}, {x: -280, z: -60}, // Top
                {x: -180, z: 280}, {x: -60, z: 280}, {x: 60, z: 280}   // Bot
            ];
            bp.forEach(p => buildTower(p.x, p.z, COLOR_BLUE));

            // Red Side Positions
            const rp = [
                {x: 60, z: -60}, {x: 120, z: -120}, {x: 180, z: -180}, // Mid
                {x: 280, z: -180}, {x: 280, z: -60}, {x: 280, z: 60},   // Bot
                {x: 180, z: -280}, {x: 60, z: -280}, {x: -60, z: -280}  // Top
            ];
            rp.forEach(p => buildTower(p.x, p.z, COLOR_RED));
        }

        function buildTower(x, z, team) {
            const tower = new THREE.Group();
            const platform = new THREE.Mesh(new THREE.CylinderGeometry(5, 6, 4, 12), new THREE.MeshStandardMaterial({color: 0x334155}));
            const shaft = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 18, 12), new THREE.MeshStandardMaterial({color: 0x1e293b}));
            shaft.position.y = 11;
            const gem = new THREE.Mesh(new THREE.OctahedronGeometry(4), new THREE.MeshStandardMaterial({color: team, emissive: team, emissiveIntensity: 1.5}));
            gem.position.y = 22;
            
            tower.add(platform); tower.add(shaft); tower.add(gem);
            tower.position.set(x, 0, z);
            scene.add(tower);
            staticObjects.push({ x, z, r: 8, team });
        }

        function populateJungle() {
            gameLog("Growing jungle flora...");
            for(let i=0; i<600; i++) {
                const x = (Math.random() - 0.5) * (WORLD_SCALE - 120);
                const z = (Math.random() - 0.5) * (WORLD_SCALE - 120);
                
                const nearRiver = Math.abs(x) < 65;
                const nearMid = Math.abs(x + z) < 60;
                const nearEdges = Math.abs(x) > 260 || Math.abs(z) > 260;

                if (!nearRiver && !nearMid) {
                    const type = Math.random();
                    if(type > 0.85) createTreeCluster(x, z);
                    else if(type > 0.6) createBushCluster(x, z);
                    else if(type > 0.45) createStoneBarrier(x, z);
                }
            }
        }

        function createTreeCluster(x, z) {
            const t = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.8, 10), new THREE.MeshStandardMaterial({color: 0x422006}));
            const l1 = new THREE.Mesh(new THREE.SphereGeometry(6, 8, 8), new THREE.MeshStandardMaterial({color: 0x064e3b}));
            l1.position.y = 8;
            const l2 = new THREE.Mesh(new THREE.SphereGeometry(4, 8, 8), new THREE.MeshStandardMaterial({color: 0x065f46}));
            l2.position.set(2, 11, 2);
            t.add(trunk); t.add(l1); t.add(l2);
            t.position.set(x, 5, z);
            scene.add(t);
        }

        function createBushCluster(x, z) {
            for(let i=0; i<3; i++) {
                const b = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(Math.random()*2 + 3),
                    new THREE.MeshStandardMaterial({ color: 0x14532d })
                );
                b.position.set(x + (i*2), 1.5, z + (Math.sin(i)*2));
                b.scale.y = 0.6;
                scene.add(b);
            }
        }

        function createStoneBarrier(x, z) {
            const s = new THREE.Mesh(
                new THREE.BoxGeometry(14, 10, 14),
                new THREE.MeshStandardMaterial({ color: 0x1f2937 })
            );
            s.position.set(x, 5, z);
            s.rotation.y = Math.random() * Math.PI;
            scene.add(s);
            staticObjects.push({ x, z, r: 10, deco: true });
        }

        /**
         * HERO MECHANICS
         */
        function initHero() {
            hero = new THREE.Group();
            
            // Body Geometry
            const armor = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 3.5, 16), new THREE.MeshStandardMaterial({ color: 0x0ea5e9, metalness: 0.5 }));
            armor.position.y = 1.75;
            hero.add(armor);
            
            // Glowing Sword
            const blade = new THREE.Mesh(new THREE.BoxGeometry(0.4, 4.5, 0.6), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x22d3ee }));
            blade.position.set(1.5, 2.5, 1);
            blade.rotation.x = 0.4;
            hero.add(blade);

            // Recall Cylinder
            recallRing = new THREE.Mesh(
                new THREE.CylinderGeometry(5, 5, 80, 32, 1, true),
                new THREE.MeshBasicMaterial({ color: 0x00f2ff, transparent: true, opacity: 0, side: THREE.DoubleSide })
            );
            recallRing.position.y = 40;
            hero.add(recallRing);

            scene.add(hero);
            hero.position.set(-320, 0, 320);
            gameLog("Hero spawn at Blue Base: Success");
        }

        /**
         * CONTROL SYSTEM
         */
        function bindControls() {
            const outer = document.getElementById('joystick-outer'), inner = document.getElementById('joystick-inner');
            
            const handleJoystick = (e) => {
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;
                const rect = outer.getBoundingClientRect();
                const oX = touch.clientX - (rect.left + 75);
                const oY = touch.clientY - (rect.top + 75);
                
                const distance = Math.min(Math.sqrt(oX*oX + oY*oY), 70);
                const angle = Math.atan2(oY, oX);
                
                inner.style.transform = `translate(calc(-50% + ${Math.cos(angle)*distance}px), calc(-50% + ${Math.sin(angle)*distance}px))`;
                dir = { x: Math.cos(angle), z: Math.sin(angle) };
                moving = true;
                if(isRecalling) breakRecall();
            };

            outer.addEventListener('touchstart', handleJoystick);
            outer.addEventListener('touchmove', handleJoystick);
            window.addEventListener('touchend', () => {
                moving = false;
                inner.style.transform = 'translate(-50%, -50%)';
            });

            // Camera Swipe Area
            const track = document.getElementById('camera-track');
            let lastX, lastY;
            track.addEventListener('touchstart', e => { lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; });
            track.addEventListener('touchmove', e => {
                camOffset.x += (e.touches[0].clientX - lastX) * 0.12;
                camOffset.z += (e.touches[0].clientY - lastY) * 0.12;
                lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
            });

            // Recall Interaction
            document.getElementById('recall-button').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if(!isRecalling && !moving) startRecallSeq();
            });
        }

        function startRecallSeq() {
            gameLog("Recall channel starting...");
            isRecalling = true;
            document.getElementById('recall-status').style.display = 'block';
            recallRing.material.opacity = 0.6;
            
            let time = 5;
            document.getElementById('r-time').innerText = time;
            
            rInterval = setInterval(() => {
                time--;
                document.getElementById('r-time').innerText = time;
                if(time <= 0) {
               
