<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>MLBB Linux Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: fixed; top: 10px; left: 10px; color: #fff; pointer-events: none; }
        #hp-bar { width: 200px; height: 20px; background: #440000; border: 2px solid #fff; }
        #hp-fill { width: 100%; height: 100%; background: #00ff00; transition: width 0.2s; }
        #console { position: fixed; bottom: 10px; left: 10px; color: #0f0; font-family: monospace; font-size: 12px; }
    </style>
</head>
<body>
    <div id="ui">
        <div>HP HERO</div>
        <div id="hp-bar"><div id="hp-fill"></div></div>
        <div style="margin-top: 5px;">CONTROLS: WASD + SPACE (Attack)</div>
    </div>
    <div id="console">> Engine Ready...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Настройки ---
        const WORLD_SIZE = 500;
        let heroHP = 100;
        const bots = [];
        const keys = {};

        // --- Инициализация сцены ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a1a0a);
        scene.fog = new THREE.Fog(0x0a1a0a, 50, 300);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(50, 100, 50);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // --- Карта ---
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE), new THREE.MeshStandardMaterial({ color: 0x152b15 }));
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Река
        const river = new THREE.Mesh(new THREE.PlaneGeometry(60, WORLD_SIZE), new THREE.MeshStandardMaterial({ color: 0x0e3a5a, transparent: true, opacity: 0.6 }));
        river.rotation.x = -Math.PI / 2;
        river.position.y = 0.1;
        scene.add(river);

        // --- Создание Героя ---
        const hero = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 2), new THREE.MeshStandardMaterial({ color: 0x0088ff }));
        body.position.y = 2;
        hero.add(body);
        scene.add(hero);
        hero.position.set(-150, 0, 150);

        // --- Создание Ботов (Враги) ---
        function createBot(x, z) {
            const botGroup = new THREE.Group();
            const botBody = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 2), new THREE.MeshStandardMaterial({ color: 0xff3300 }));
            botBody.position.y = 2;
            botGroup.add(botBody);
            
            // ХП бар над ботом
            const hpGeo = new THREE.PlaneGeometry(3, 0.4);
            const hpMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const hpMesh = new THREE.Mesh(hpGeo, hpMat);
            hpMesh.position.y = 5;
            botGroup.add(hpMesh);

            botGroup.position.set(x, 0, z);
            scene.add(botGroup);
            
            bots.push({
                mesh: botGroup,
                hp: 50,
                state: 'idle',
                lastAttack: 0
            });
        }

        // Спавним ботов на лайнах
        createBot(0, 0);   // Мид
        createBot(100, -100); // Топ
        createBot(-50, 50);  // Лес

        // --- Управление ---
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        function updateHero() {
            const speed = 0.8;
            if (keys['KeyW']) hero.position.z -= speed;
            if (keys['KeyS']) hero.position.z += speed;
            if (keys['KeyA']) hero.position.x -= speed;
            if (keys['KeyD']) hero.position.x += speed;

            // Атака (Пробел)
            if (keys['Space']) {
                attackNearby();
            }

            // Камера следует за героем
            camera.position.set(hero.position.x, 60, hero.position.z + 40);
            camera.lookAt(hero.position);
        }

        function attackNearby() {
            bots.forEach(bot => {
                const dist = hero.position.distanceTo(bot.mesh.position);
                if (dist < 8) {
                    bot.hp -= 1;
                    log("Урон по боту! HP: " + bot.hp);
                    if (bot.hp <= 0) {
                        scene.remove(bot.mesh);
                        bots.splice(bots.indexOf(bot), 1);
                        log("Бот уничтожен!");
                    }
                }
            });
        }

        // --- Логика Ботов ---
        function updateBots() {
            const now = Date.now();
            bots.forEach(bot => {
                const dist = bot.mesh.position.distanceTo(hero.position);

                // Если герой близко — бот идет бить
                if (dist < 40 && dist > 3) {
                    bot.mesh.lookAt(hero.position);
                    bot.mesh.translateZ(0.3);
                    bot.state = 'chase';
                } 
                
                // Если совсем близко — наносит урон герою
                if (dist <= 5 && now - bot.lastAttack > 1000) {
                    heroHP -= 5;
                    bot.lastAttack = now;
                    document.getElementById('hp-fill').style.width = heroHP + "%";
                    log("Бот ударил тебя! Твое HP: " + heroHP);
                }
            });
        }

        function log(m) {
            document.getElementById('console').innerText = "> " + m;
        }

        // --- Цикл игры ---
        function animate() {
            requestAnimationFrame(animate);
            if (heroHP > 0) {
                updateHero();
                updateBots();
            } else {
                log("GAME OVER. REFRESH TO RESTART.");
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
