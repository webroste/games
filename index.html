<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MLBB Clone: Full UI</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050a05; touch-action: none; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }
        
        /* --- UI –°–õ–û–ò --- */
        .screen { position: absolute; inset: 0; display: none; flex-direction: column; align-items: center; justify-content: center; }
        
        /* –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ */
        #menu-screen { display: flex; background: url('https://img.freepik.com/free-vector/dark-green-low-poly-background_1017-33742.jpg') center/cover; z-index: 200; }
        h1 { color: gold; font-size: 40px; text-shadow: 0 0 10px black; margin-bottom: 30px; text-transform: uppercase; }
        .btn {
            background: linear-gradient(to bottom, #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%);
            border: 2px solid gold; border-radius: 8px; color: white;
            padding: 15px 40px; font-size: 20px; font-weight: bold; margin: 10px;
            cursor: pointer; box-shadow: 0 5px 15px rgba(0,0,0,0.5); text-transform: uppercase;
        }
        .btn:active { transform: scale(0.95); }

        /* –ù–ê–°–¢–†–û–ô–ö–ò */
        #settings-screen { background: rgba(0,0,0,0.9); z-index: 210; color: white; }
        .setting-row { margin: 15px; display: flex; justify-content: space-between; width: 300px; align-items: center; }
        input[type=range] { width: 150px; }

        /* –ò–ì–†–û–í–û–ô –ò–ù–¢–ï–†–§–ï–ô–° */
        #game-ui { pointer-events: none; z-index: 100; }
        
        /* –ú–∏–Ω–∏-–∫–∞—Ä—Ç–∞ */
        #minimap {
            position: absolute; top: 15px; left: 15px;
            width: 130px; height: 130px;
            background: rgba(0, 10, 0, 0.8);
            border: 2px solid #666; border-radius: 8px;
            overflow: hidden; pointer-events: none;
        }
        #minimap-player {
            position: absolute; width: 6px; height: 6px;
            background: #00ff00; border-radius: 50%; box-shadow: 0 0 4px #00ff00;
            transform: translate(-50%, -50%);
        }

        /* –î–∂–æ–π—Å—Ç–∏–∫ */
        #joy-container {
            position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px;
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 50%;
            pointer-events: auto;
        }
        #joy-stick {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(255,255,255,0.6); border-radius: 50%; transform: translate(-50%, -50%);
        }

        /* –ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π */
        #actions { position: absolute; bottom: 40px; right: 40px; pointer-events: auto; display: flex; gap: 15px; align-items: flex-end;}
        .skill-btn {
            width: 60px; height: 60px; border-radius: 50%; border: 2px solid white;
            background: rgba(0,0,0,0.5); color: white; font-weight: bold;
            display: flex; align-items: center; justify-content: center; font-size: 12px;
        }
        #recall-btn { background: #442266; border-color: #aa55ff; }
        #attack-btn { width: 80px; height: 80px; background: #662222; border-color: #ff5555; font-size: 16px; }

        /* –°–æ–æ–±—â–µ–Ω–∏–µ –æ —Ä–µ–∫–æ–ª–µ */
        #recall-msg {
            position: absolute; bottom: 150px; width: 100%; text-align: center;
            color: #00ffff; font-size: 24px; font-weight: bold; text-shadow: 0 0 5px black;
            display: none;
        }
    </style>
</head>
<body>

    <div id="menu-screen" class="screen">
        <h1>MOBA LEGENDS</h1>
        <button class="btn" onclick="startGame()">–ò–ì–†–ê–¢–¨</button>
        <button class="btn" onclick="openSettings()">–ù–ê–°–¢–†–û–ô–ö–ò</button>
    </div>

    <div id="settings-screen" class="screen">
        <h2>–ù–ê–°–¢–†–û–ô–ö–ò</h2>
        <div class="setting-row">
            <span>–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫–∞–º–µ—Ä—ã:</span>
            <input type="range" min="0.5" max="3" step="0.1" value="1" oninput="updateSettings('sens', this.value)">
        </div>
        <div class="setting-row">
            <span>–ò–Ω–≤–µ—Ä—Å–∏—è X:</span>
            <input type="checkbox" onchange="updateSettings('invX', this.checked)">
        </div>
        <div class="setting-row">
            <span>–ò–Ω–≤–µ—Ä—Å–∏—è Y:</span>
            <input type="checkbox" onchange="updateSettings('invY', this.checked)">
        </div>
        <button class="btn" style="background: #555;" onclick="closeSettings()">–ù–ê–ó–ê–î</button>
    </div>

    <div id="game-ui" class="screen">
        <div id="minimap"><div id="minimap-player"></div></div>
        <div id="joy-container"><div id="joy-stick"></div></div>
        
        <div id="recall-msg">–í–û–ó–í–†–ê–©–ï–ù–ò–ï... <span id="recall-timer">5</span></div>

        <div id="actions">
            <div id="recall-btn" class="skill-btn" ontouchstart="startRecall()">üè†</div>
            <div id="attack-btn" class="skill-btn">‚öîÔ∏è</div>
        </div>
        
        <div id="camera-zone" style="position: absolute; top:0; right:0; width: 50%; height: 100%; pointer-events: auto;"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò ---
        const Settings = {
            camSens: 1.0,
            invX: false,
            invY: false
        };

        window.updateSettings = (key, val) => {
            if (key === 'sens') Settings.camSens = parseFloat(val);
            if (key === 'invX') Settings.invX = val;
            if (key === 'invY') Settings.invY = val;
        };

        // --- –õ–û–ì–ò–ö–ê –ò–ì–†–´ ---
        let scene, camera, renderer, player, obstacles = [];
        let joyX = 0, joyZ = 0, isMoving = false;
        let isRecalling = false, recallTimeout;
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∫–∞–º–µ—Ä—ã
        let camPanX = 0, camPanZ = 0;
        let camBaseOffset = { x: 0, y: 18, z: 14 };

        const MAP_SIZE = 100;
        const SPAWN_POS = { x: -32, z: 32 }; // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Å–ø–∞–≤–Ω (—Ä—è–¥–æ–º —Å —Ç—Ä–æ–Ω–æ–º)

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a100a);
            scene.fog = new THREE.Fog(0x0a100a, 20, 90);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 0.9);
            sun.position.set(20, 50, 20);
            scene.add(sun);

            createLevel();

            // –°–æ–∑–¥–∞–µ–º –≥–µ—Ä–æ—è
            player = new Hero(scene, 0x0088ff);
            player.group.position.set(SPAWN_POS.x, 0, SPAWN_POS.z);

            setupControls();
            setupCameraInput();
            
            animate();
        }

        // --- –£–ü–†–ê–í–õ–ï–ù–ò–ï –ú–ï–ù–Æ ---
        window.startGame = () => {
            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';
            if (!scene) init();
        };
        window.openSettings = () => {
            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('settings-screen').style.display = 'flex';
        };
        window.closeSettings = () => {
            document.getElementById('settings-screen').style.display = 'none';
            document.getElementById('menu-screen').style.display = 'flex';
        };

        // --- –ì–ï–ù–ï–†–ê–¶–ò–Ø –ö–ê–†–¢–´ ---
        function createLevel() {
            // –ó–µ–º–ª—è
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE), new THREE.MeshStandardMaterial({ color: 0x152515 }));
            ground.rotation.x = -Math.PI/2;
            scene.add(ground);

            // –†–µ–∫–∞ (–¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–∞—è)
            const riverGeo = new THREE.PlaneGeometry(MAP_SIZE * 1.5, 8);
            const riverMat = new THREE.MeshStandardMaterial({ color: 0x224466, roughness: 0.2 });
            const river = new THREE.Mesh(riverGeo, riverMat);
            river.rotation.x = -Math.PI/2;
            river.rotation.z = -Math.PI/4;
            river.position.y = 0.05;
            scene.add(river);

            // –õ–∏–Ω–∏–∏
            const lineMat = new THREE.MeshBasicMaterial({ color: 0x334433 });
            const mid = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE*1.4, 3), lineMat);
            mid.rotation.x = -Math.PI/2; mid.rotation.z = Math.PI/4; mid.position.y = 0.06;
            scene.add(mid);

            // –ë–ê–ó–´ (–¢—Ä–æ–Ω—ã)
            addObj(-42, 42, 5, 8, 0x003366, "Base"); // –°–∏–Ω—è—è (–°–æ—é–∑–Ω–∞—è)
            addObj(42, -42, 5, 8, 0x661111, "Base"); // –ö—Ä–∞—Å–Ω–∞—è (–í—Ä–∞–≥)

            // –ë–ê–®–ù–ò (Turrets)
            addObj(-20, 20, 2.5, 6, 0x445566, "Tower"); // –ú–∏–¥ –°–∏–Ω–∏–π
            addObj(20, -20, 2.5, 6, 0x443333, "Tower"); // –ú–∏–¥ –ö—Ä–∞—Å–Ω—ã–π

            // –î–ï–ö–û–† (–õ–µ—Å –∏ –ö–∞–º–Ω–∏)
            for(let i=0; i<80; i++) {
                let rx = (Math.random() - 0.5) * MAP_SIZE;
                let rz = (Math.random() - 0.5) * MAP_SIZE;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ–±—ã –Ω–µ —Å—Ç–∞–≤–∏—Ç—å –Ω–∞ –±–∞–∑–µ –∏ –ª–∏–Ω–∏—è—Ö
                if (Math.abs(rx + rz) > 12 && Math.abs(rx - rz) > 12 && Math.abs(rx)>8) {
                    // 70% –î–µ—Ä–µ–≤—å—è, 30% –ö–∞–º–Ω–∏/–ö—É—Å—Ç—ã
                    if (Math.random() > 0.3) {
                        addObj(rx, rz, 1 + Math.random(), 4 + Math.random()*3, 0x0b1a0b, "Tree");
                    } else {
                        addObj(rx, rz, 1.5, 1.5, 0x3a4a3a, "Rock");
                    }
                }
            }
        }

        function addObj(x, z, r, h, color, type) {
            let geo;
            if (type === "Rock") geo = new THREE.BoxGeometry(r*2, h, r*2);
            else geo = new THREE.CylinderGeometry(r*0.8, r, h, 7);

            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color }));
            mesh.position.set(x, h/2, z);
            mesh.userData.radius = r;
            scene.add(mesh);
            obstacles.push(mesh);
            
            // –¢–æ—á–∫–∞ –Ω–∞ –º–∏–Ω–∏-–∫–∞—Ä—Ç–µ
            let dotColor = (type === "Base") ? "gold" : (type === "Tower" ? "silver" : "#224422");
            if (type === "Tree") return; // –î–µ—Ä–µ–≤—å—è –Ω–µ —Ä–∏—Å—É–µ–º –Ω–∞ –∫–∞—Ä—Ç–µ —á—Ç–æ–±—ã –Ω–µ –∑–∞—Å–æ—Ä—è—Ç—å
            createMinimapDot(x, z, dotColor);
        }

        // --- –ì–ï–†–û–ô ---
        class Hero {
            constructor(scene, color) {
                this.group = new THREE.Group();
                // –¢–µ–ª–æ
                const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 1, 4, 8), new THREE.MeshStandardMaterial({ color }));
                body.position.y = 0.9;
                this.group.add(body);
                // –ö–æ–ª—å—Ü–æ –ø–æ–¥ –Ω–æ–≥–∞–º–∏ (–≤—ã–¥–µ–ª–µ–Ω–∏–µ)
                const ring = new THREE.Mesh(new THREE.RingGeometry(0.7, 0.8, 32), new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide }));
                ring.rotation.x = -Math.PI/2;
                ring.position.y = 0.05;
                this.group.add(ring);
                
                scene.add(this.group);
                this.radius = 0.6;
                this.speed = 0.12;
            }
            update(mx, mz, obstacles) {
                if (mx === 0 && mz === 0) return;
                
                // –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ —Ä–µ–∫–æ–ª–∞ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏
                if (isRecalling) cancelRecall();

                let nextX = this.group.position.x + mx * this.speed;
                let nextZ = this.group.position.z + mz * this.speed;
                
                // –ü—Ä–æ—Å—Ç–∞—è –∫–æ–ª–ª–∏–∑–∏—è
                let collide = false;
                for (let obj of obstacles) {
                    const dist = Math.sqrt((nextX - obj.position.x)**2 + (nextZ - obj.position.z)**2);
                    if (dist < this.radius + (obj.userData.radius || 1)) { collide = true; break; }
                }

                // –ì—Ä–∞–Ω–∏—Ü—ã –∫–∞—Ä—Ç—ã
                if (Math.abs(nextX) > MAP_SIZE/2 - 1) collide = true;
                if (Math.abs(nextZ) > MAP_SIZE/2 - 1) collide = true;

                if (!collide) {
                    this.group.position.set(nextX, 0, nextZ);
                }
                this.group.rotation.y = Math.atan2(mx, mz);
            }
        }

        // --- –õ–û–ì–ò–ö–ê –†–ï–ö–û–õ–ê (–í–û–ó–í–†–ê–©–ï–ù–ò–ï) ---
        window.startRecall = () => {
            if (isRecalling || isMoving) return;
            isRecalling = true;
            document.getElementById('recall-msg').style.display = 'block';
            let timeLeft = 5;
            document.getElementById('recall-timer').innerText = timeLeft;

            // –≠—Ñ—Ñ–µ–∫—Ç –≤—Ä–∞—â–µ–Ω–∏—è (–≤–∏–∑—É–∞–ª—å–Ω—ã–π)
            const spinInterval = setInterval(() => {
                if (!isRecalling) { clearInterval(spinInterval); return; }
                player.group.rotation.y += 0.5;
            }, 50);

            const timerInterval = setInterval(() => {
                if (!isRecalling) { clearInterval(timerInterval); return; }
                timeLeft--;
                document.getElementById('recall-timer').innerText = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    finishRecall();
                }
            }, 1000);

            recallTimeout = { spin: spinInterval, timer: timerInterval };
        };

        function cancelRecall() {
            isRecalling = false;
            document.getElementById('recall-msg').style.display = 'none';
        }

        function finishRecall() {
            cancelRecall();
            player.group.position.set(SPAWN_POS.x, 0, SPAWN_POS.z);
            // –≠—Ñ—Ñ–µ–∫—Ç —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞ (–≤—Å–ø—ã—à–∫–∞ –∫–∞–º–µ—Ä—ã)
            renderer.domElement.style.opacity = 0;
            setTimeout(() => renderer.domElement.style.opacity = 1, 200);
        }


        // --- –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–ê–ú–ï–†–û–ô (–°–í–ê–ô–ü–´) ---
        function setupCameraInput() {
            const zone = document.getElementById('camera-zone');
            let startX, startY;

            zone.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
            }, {passive: false});

            zone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const dx = e.touches[0].clientX - startX;
                const dy = e.touches[0].clientY - startY;

                // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (–∏–Ω–≤–µ—Ä—Å–∏—è –∏ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å)
                const sens = 0.05 * Settings.camSens;
                const dirX = Settings.invX ? -1 : 1;
                const dirY = Settings.invY ? -1 : 1;

                camPanX += dx * sens * dirX;
                camPanZ += dy * sens * dirY;

                // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–∞–ª—å–Ω–æ—Å—Ç–∏ –æ—Å–º–æ—Ç—Ä–∞
                camPanX = Math.max(-15, Math.min(15, camPanX));
                camPanZ = Math.max(-15, Math.min(15, camPanZ));

                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
            }, {passive: false});

            zone.addEventListener('touchend', () => {
                // –ü–ª–∞–≤–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç –∫–∞–º–µ—Ä—ã (–±—É–¥–µ—Ç –≤ animate)
            });
        }

        // --- –î–ñ–û–ô–°–¢–ò–ö ---
        function setupControls() {
            const container = document.getElementById('joy-container');
            const stick = document.getElementById('joy-stick');
            const handle = (e) => {
                e.preventDefault();
                const t = e.touches[0];
                const r = container.getBoundingClientRect();
                const dx = t.clientX - (r.left + 60);
                const dy = t.clientY - (r.top + 60);
                const d = Math.min(Math.sqrt(dx*dx+dy*dy), 50);
                const a = Math.atan2(dy, dx);
                stick.style.transform = `translate(calc(-50% + ${Math.cos(a)*d}px), calc(-50% + ${Math.sin(a)*d}px))`;
                joyX = Math.cos(a)*(d/50); joyZ = Math.sin(a)*(d/50);
                isMoving = true;
            };
            container.addEventListener('touchstart', handle, {passive:false});
            container.addEventListener('touchmove', handle, {passive:false});
            container.addEventListener('touchend', () => { 
                isMoving = false; joyX = 0; joyZ = 0; 
                stick.style.transform = 'translate(-50%, -50%)'; 
            });
        }

        // --- MINI MAP ---
        function createMinimapDot(x, z, color) {
            const dot = document.createElement('div');
            dot.style.position = 'absolute'; dot.style.width = '4px'; dot.style.height = '4px';
            dot.style.background = color; dot.style.borderRadius = '50%';
            let mx = ((x + MAP_SIZE/2)/MAP_SIZE)*130;
            let my = ((z + MAP_SIZE/2)/MAP_SIZE)*130;
            dot.style.left = mx+'px'; dot.style.top = my+'px';
            document.getElementById('minimap').appendChild(dot);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!isRecalling && isMoving) player.update(joyX, joyZ, obstacles);

            // –õ–æ–≥–∏–∫–∞ –∫–∞–º–µ—Ä—ã: –°–Ω–∞–ø–±—ç–∫ (–≤–æ–∑–≤—Ä–∞—Ç), –µ—Å–ª–∏ –ø–∞–ª–µ—Ü –æ—Ç–ø—É—â–µ–Ω
            // –ï—Å–ª–∏ –¥–∂–æ–π—Å—Ç–∏–∫ –∞–∫—Ç–∏–≤–µ–Ω, –∫–∞–º–µ—Ä–∞ —Ç–æ–∂–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –±—ã—Å—Ç—Ä–µ–µ
            if (!isMoving) { // –ï—Å–ª–∏ —Å—Ç–æ–∏–º, –ø–æ–∑–≤–æ–ª—è–µ–º —Å–º–æ—Ç—Ä–µ—Ç—å
                camPanX *= 0.95; // –ú–µ–¥–ª–µ–Ω–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç
                camPanZ *= 0.95;
            } else {
                camPanX *= 0.8; // –ë—ã—Å—Ç—Ä—ã–π –≤–æ–∑–≤—Ä–∞—Ç –ø—Ä–∏ –±–µ–≥–µ
                camPanZ *= 0.8;
            }

            // –ü–æ–∑–∏—Ü–∏—è –∫–∞–º–µ—Ä—ã = –ü–æ–∑–∏—Ü–∏—è –≥–µ—Ä–æ—è + –ë–∞–∑–æ–≤—ã–π –æ—Ñ—Ñ—Å–µ—Ç + –†—É—á–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ
            camera.position.x = player.group.position.x + camBaseOffset.x + camPanX;
            camera.position.y = camBaseOffset.y; // –í—ã—Å–æ—Ç–∞ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞
            camera.position.z = player.group.position.z + camBaseOffset.z + camPanZ;
            
            // –ö–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ —Ç–æ—á–∫—É —á—É—Ç—å –≤–ø–µ—Ä–µ–¥–∏ –≥–µ—Ä–æ—è + —Å–º–µ—â–µ–Ω–∏–µ
            camera.lookAt(
                player.group.position.x + camPanX, 
                0, 
                player.group.position.z + camPanZ
            );

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–∏–Ω–∏-–∫–∞—Ä—Ç—ã
            const pDot = document.getElementById('minimap-player');
            pDot.style.left = ((player.group.position.x + MAP_SIZE/2)/MAP_SIZE)*130 + 'px';
            pDot.style.top = ((player.group.position.z + MAP_SIZE/2)/MAP_SIZE)*130 + 'px';

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            if(camera){
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
