<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MOBA Legends: Professional Build</title>
    <style>
        :root {
            --gold: #ffcc00;
            --blue-team: #2563eb;
            --red-team: #dc2626;
            --bg-dark: #010409;
        }

        body { 
            margin: 0; overflow: hidden; background: var(--bg-dark); 
            touch-action: none; font-family: 'Segoe UI', Roboto, sans-serif; 
            user-select: none; -webkit-user-select: none; color: white;
        }

        /* –ö–û–ù–°–û–õ–¨ –û–¢–õ–ê–î–ö–ò */
        #terminal {
            position: absolute; top: 10px; left: 10px; width: 350px; height: 250px;
            background: rgba(0, 0, 0, 0.95); border: 1px solid #30363d;
            border-radius: 12px; z-index: 10000; font-family: 'Consolas', monospace;
            font-size: 12px; padding: 15px; overflow-y: auto; display: none;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8); pointer-events: none;
        }
        .t-success { color: #4ade80; }
        .t-error { color: #f87171; }
        .t-warn { color: #fbbf24; }

        /* –≠–ö–†–ê–ù–´ */
        .overlay { 
            position: absolute; inset: 0; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; z-index: 500; 
        }
        #main-menu { 
            background: radial-gradient(circle at center, #1e3a8a 0%, #010409 100%); 
        }
        
        .game-logo { 
            font-size: 60px; font-weight: 900; color: var(--gold); letter-spacing: 15px;
            text-shadow: 0 0 30px rgba(255, 204, 0, 0.5); margin-bottom: 40px;
            text-align: center; line-height: 1.2;
        }

        .play-button {
            background: linear-gradient(180deg, #3b82f6 0%, #1d4ed8 100%);
            border: 3px solid var(--gold); color: white; padding: 25px 90px;
            font-size: 26px; font-weight: bold; border-radius: 20px; cursor: pointer;
            text-transform: uppercase; box-shadow: 0 8px 0 #1e3a8a;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .play-button:active { transform: translateY(5px); box-shadow: 0 3px 0 #1e3a8a; }

        /* –ò–ù–¢–ï–†–§–ï–ô–° –ë–û–Ø */
        #battle-hud { display: none; pointer-events: none; opacity: 1; }

        #minimap-frame {
            position: absolute; top: 20px; left: 20px; width: 220px; height: 220px;
            background: rgba(13, 17, 23, 0.9); border: 2px solid #484f58;
            border-radius: 15px; overflow: hidden; pointer-events: auto;
        }
        #minimap-canvas { width: 100%; height: 100%; }

        /* –£–ü–†–ê–í–õ–ï–ù–ò–ï */
        #joy-container {
            position: absolute; bottom: 50px; left: 50px; width: 160px; height: 160px;
            background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.1);
            border-radius: 50%; pointer-events: auto; backdrop-filter: blur(4px);
        }
        #joy-knob {
            position: absolute; top: 50%; left: 50%; width: 70px; height: 70px;
            background: radial-gradient(circle, #fff, #94a3b8); border-radius: 50%;
            transform: translate(-50%, -50%); box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        #recall-action {
            position: absolute; bottom: 60px; right: 60px; width: 110px; height: 110px;
            background: radial-gradient(circle, #4f46e5, #312e81); border: 4px solid white;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 45px; pointer-events: auto; cursor: pointer;
            box-shadow: 0 0 40px rgba(79, 70, 229, 0.5);
        }

        #ui-message {
            position: absolute; bottom: 220px; width: 100%; text-align: center;
            font-size: 36px; font-weight: 900; color: #00e5ff; display: none;
            text-shadow: 0 0 20px black; pointer-events: none;
        }

        #btn-debug {
            position: absolute; top: 20px; right: 20px; padding: 15px 25px;
            background: #21262d; border: 1px solid #30363d; border-radius: 30px;
            z-index: 10001; cursor: pointer; font-weight: bold; font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="terminal"></div>
    <div id="btn-debug" onclick="toggleTerminal()">CONSOLE [OFF]</div>

    <div id="main-menu" class="overlay">
        <div class="game-logo">MOBA<br>LEGENDS</div>
        <button class="play-button" onclick="startGameEngine()">–í –ë–û–ô</button>
    </div>

    <div id="battle-hud" class="overlay">
        <div id="minimap-frame"><canvas id="minimap-canvas"></canvas></div>
        <div id="joy-container"><div id="joy-knob"></div></div>
        <div id="ui-message">–í–û–ó–í–†–ê–¢... <span id="r-timer">5</span></div>
        <div id="recall-action">üè†</div>
        <div id="camera-zone" style="position:absolute; right:0; top:0; width:60%; height:100%; pointer-events:auto;"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        /**
         * –°–ï–†–í–ò–° –õ–û–ì–ò–†–û–í–ê–ù–ò–Ø (–ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –ø–µ—Ä–≤—ã–º)
         */
        const logger = {
            log: (msg, type = 'info') => {
                console.log(`[${type}] ${msg}`);
                const term = document.getElementById('terminal');
                const line = document.createElement('div');
                line.className = `t-${type}`;
                line.innerText = `> ${new Date().toLocaleTimeString().split(' ')[0]} ${msg}`;
                term.appendChild(line);
                term.scrollTop = term.scrollHeight;
            }
        };

        function toggleTerminal() {
            const t = document.getElementById('terminal');
            const b = document.getElementById('btn-debug');
            const isVisible = t.style.display === 'block';
            t.style.display = isVisible ? 'none' : 'block';
            b.innerText = `CONSOLE [${isVisible ? 'OFF' : 'ON'}]`;
        }

        /**
         * –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï
         */
        let engine_scene, engine_camera, engine_renderer, hero_unit, recall_fx;
        let map_obstacles = [], map_decorations = [];
        let input_moving = false, input_vector = { x: 0, z: 0 };
        let state_recalling = false, recall_clock;
        let view_offset = { x: 0, z: 0 };

        const WORLD_DIM = 900;
        const TEAM_BLUE = 0x2563eb;
        const TEAM_RED = 0xdc2626;

        /**
         * –ó–ê–ü–£–°–ö –î–í–ò–ñ–ö–ê
         */
        function startGameEngine() {
            logger.log("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º...", "success");
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('battle-hud').style.display = 'block';

            try {
                setupThreeJS();
                generateBattlefield();
                spawnHeroUnit();
                initControllers();
                logger.log("–í—Å–µ —Å–∏—Å—Ç–µ–º—ã –∞–∫—Ç–∏–≤–Ω—ã. –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –†–∞—Å—Å–≤–µ—Ç–Ω—ã–π –î–æ–ª!", "success");
                coreLoop();
            } catch (e) {
                logger.log("–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: " + e.message, "error");
            }
        }

        function setupThreeJS() {
            engine_scene = new THREE.Scene();
            engine_scene.background = new THREE.Color(0x010409);
            engine_scene.fog = new THREE.Fog(0x010409, 50, 300);

            engine_camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            engine_renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            engine_renderer.setSize(window.innerWidth, window.innerHeight);
            engine_renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(engine_renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            engine_scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(100, 200, 100);
            engine_scene.add(sun);
            
            logger.log("–ì—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–µ —è–¥—Ä–æ Three.js –∑–∞–ø—É—â–µ–Ω–æ");
        }

        /**
         * –ì–ï–ù–ï–†–ê–¶–ò–Ø –ö–ê–†–¢–´
         */
        function generateBattlefield() {
            // –ó–µ–º–ª—è
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(WORLD_DIM, WORLD_DIM),
                new THREE.MeshStandardMaterial({ color: 0x064e3b })
            );
            ground.rotation.x = -Math.PI / 2;
            engine_scene.add(ground);

            // –†–µ–∫–∞
            const river = new THREE.Mesh(
                new THREE.PlaneGeometry(120, WORLD_DIM),
                new THREE.MeshStandardMaterial({ color: 0x0c4a6e, transparent: true, opacity: 0.8 })
            );
            river.rotation.x = -Math.PI / 2;
            river.position.y = 0.05;
            engine_scene.add(river);

            // –õ–∞–π–Ω—ã
            createLane(0, 0, Math.PI / 4); // Mid
            createLane(-320, 0, 0); // Top
            createLane(320, 0, 0);  // Bot
            createLane(0, -320, Math.PI / 2); // Red Base Road
            createLane(0, 320, Math.PI / 2);  // Blue Base Road

            // –†–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–∞—à–µ–Ω (–ú–∏–¥)
            for(let i=1; i<=3; i++) {
                createTower(-60 * i, 60 * i, TEAM_BLUE);
                createTower(60 * i, -60 * i, TEAM_RED);
            }

            // –†–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–∞—à–µ–Ω (–¢–æ–ø –∏ –ë–æ—Ç)
            [320, -320].forEach(sideX => {
                const team = sideX < 0 ? TEAM_BLUE : TEAM_RED;
                for(let j=0; j<3; j++) {
                    createTower(sideX, (j * 80) - (sideX < 0 ? 0 : 200), team);
                    createTower((j * 80) - (sideX < 0 ? 0 : 200), -sideX, team);
                }
            });

            // –ì–ª–∞–≤–Ω—ã–µ –±–∞–∑—ã
            createBaseThrone(-380, 380, TEAM_BLUE);
            createBaseThrone(380, -380, TEAM_RED);

            // –õ–∞–Ω–¥—à–∞—Ñ—Ç –¥–∂—É–Ω–≥–ª–µ–π
            for(let k=0; k<800; k++) {
                let rx = (Math.random() - 0.5) * (WORLD_DIM - 100);
                let rz = (Math.random() - 0.5) * (WORLD_DIM - 100);
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–æ–Ω –¥–æ—Ä–æ–≥ –∏ —Ä–µ–∫–∏
                if (Math.abs(rx) > 70 && Math.abs(rx + rz) > 60) {
                    const seed = Math.random();
                    if (seed > 0.9) spawnWall(rx, rz);
                    else if (seed > 0.6) spawnTree(rx, rz);
                    else if (seed > 0.4) spawnBush(rx, rz);
                }
            }
            logger.log("–õ–∞–Ω–¥—à–∞—Ñ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω: 18 –±–∞—à–µ–Ω, 2 —Ç—Ä–æ–Ω–∞, 800 –æ–±—ä–µ–∫—Ç–æ–≤ –¥–∂—É–Ω–≥–ª–µ–π");
        }

        function createLane(x, z, rot) {
            const lane = new THREE.Mesh(
                new THREE.PlaneGeometry(60, 1500),
                new THREE.MeshStandardMaterial({ color: 0x1e293b })
            );
            lane.rotation.x = -Math.PI / 2;
            lane.rotation.z = rot;
            lane.position.set(x, 0.1, z);
            engine_scene.add(lane);
        }

        function createTower(x, z, team) {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.CylinderGeometry(4, 6, 20, 8), new THREE.MeshStandardMaterial({color: 0x475569}));
            b.position.y = 10;
            const c = new THREE.Mesh(new THREE.OctahedronGeometry(5), new THREE.MeshStandardMaterial({color: team, emissive: team}));
            c.position.y = 22;
            g.add(b); g.add(c);
            g.position.set(x, 0, z);
            engine_scene.add(g);
            map_obstacles.push({ x, z, r: 8, team: team === TEAM_BLUE ? 'blue' : 'red' });
        }

        function createBaseThrone(x, z, team) {
            const g = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(20, 30, 20), new THREE.MeshStandardMaterial({color: 0x0f172a}));
            body.position.y = 15;
            const crystal = new THREE.Mesh(new THREE.IcosahedronGeometry(10), new THREE.MeshStandardMaterial({color: team, emissive: team}));
            crystal.position.y = 35;
            g.add(body); g.add(crystal);
            g.position.set(x, 0, z);
            engine_scene.add(g);
            map_obstacles.push({ x, z, r: 20, team: team === TEAM_BLUE ? 'blue' : 'red', throne: true });
        }

        function spawnTree(x, z) {
            const tree = new THREE.Group();
            const t = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.5, 10), new THREE.MeshStandardMaterial({color: 0x422006}));
            const l = new THREE.Mesh(new THREE.SphereGeometry(6, 8, 8), new THREE.MeshStandardMaterial({color: 0x065f46}));
            l.position.y = 8;
            tree.add(t); tree.add(l);
            tree.position.set(x, 5, z);
            engine_scene.add(tree);
        }

        function spawnBush(x, z) {
            const b = new THREE.Mesh(new THREE.DodecahedronGeometry(5), new THREE.MeshStandardMaterial({color: 0x14532d}));
            b.scale.y = 0.5;
            b.position.set(x, 2, z);
            engine_scene.add(b);
        }

        function spawnWall(x, z) {
            const w = new THREE.Mesh(new THREE.BoxGeometry(15, 12, 15), new THREE.MeshStandardMaterial({color: 0x334155}));
            w.position.set(x, 6, z);
            w.rotation.y = Math.random() * Math.PI;
            engine_scene.add(w);
            map_obstacles.push({ x, z, r: 10, deco: true });
        }

        /**
         * –ì–ï–†–û–ô
         */
        function spawnHeroUnit() {
            hero_unit = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 4, 16), new THREE.MeshStandardMaterial({ color: 0x0ea5e9 }));
            body.position.y = 2;
            hero_unit.add(body);

            const sword = new THREE.Mesh(new THREE.BoxGeometry(0.5, 5, 0.5), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x22d3ee }));
            sword.position.set(1.8, 3, 1);
            sword.rotation.x = 0.5;
            hero_unit.add(sword);

            recall_fx = new THREE.Mesh(
                new THREE.CylinderGeometry(6, 6, 100, 32, 1, true),
                new THREE.MeshBasicMaterial({ color: 0x00f2ff, transparent: true, opacity: 0, side: THREE.DoubleSide })
            );
            recall_fx.position.y = 50;
            hero_unit.add(recall_fx);

            engine_scene.add(hero_unit);
            hero_unit.position.set(-380, 0, 380);
            logger.log("–ì–µ—Ä–æ–π –∑–∞—Å–ø–∞–≤–Ω–µ–Ω –Ω–∞ —Å–∏–Ω–µ–π –±–∞–∑–µ");
        }

        /**
         * –£–ü–†–ê–í–õ–ï–ù–ò–ï
         */
        function initControllers() {
            const joy = document.getElementById('joy-container'), knob = document.getElementById('joy-knob');
            
            const handleTouch = (e) => {
                e.preventDefault();
                const t = e.touches ? e.touches[0] : e;
                const r = joy.getBoundingClientRect();
                const dx = t.clientX - (r.left + 80), dy = t.clientY - (r.top + 80);
                const d = Math.min(Math.sqrt(dx*dx + dy*dy), 70);
                const a = Math.atan2(dy, dx);
                
                knob.style.transform = `translate(calc(-50% + ${Math.cos(a)*d}px), calc(-50% + ${Math.sin(a)*d}px))`;
                input_vector = { x: Math.cos(a), z: Math.sin(a) };
                input_moving = true;
                if(state_recalling) cancelRecall();
            };

            joy.addEventListener('touchstart', handleTouch);
            joy.addEventListener('touchmove', handleTouch);
            window.addEventListener('touchend', () => {
                input_moving = false;
                knob.style.transform = 'translate(-50%, -50%)';
            });

            // –ö–∞–º–µ—Ä–∞
            const cam = document.getElementById('camera-zone');
            let lx, ly;
            cam.addEventListener('touchstart', e => { lx = e.touches[0].clientX; ly = e.touches[0].clientY; });
            cam.addEventListener('touchmove', e => {
                view_offset.x += (e.touches[0].clientX - lx) * 0.15;
                view_offset.z += (e.touches[0].clientY - ly) * 0.15;
                lx = e.touches[0].clientX; ly = e.touches[0].clientY;
            });

            // –ö–Ω–æ–ø–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞
            document.getElementById('recall-action').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if(!state_recalling && !input_moving) startRecall();
            });
        }

        function startRecall() {
            logger.log("–ù–∞—á–∞–ª–æ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏...");
            state_recalling = true;
            document.getElementById('ui-message').style.display = 'block';
            recall_fx.material.opacity = 0.6;
            let time = 5;
            document.getElementById('r-timer').innerText = time;
            recall_clock = setInterval(() => {
                time--;
                document.getElementById('r-timer').innerText = time;
                if(time <= 0) {
                    hero_unit.position.set(-380, 0, 380);
                    cancelRecall();
                    logger.log("–ì–µ—Ä–æ–π –≤–µ—Ä–Ω—É–ª—Å—è –Ω–∞ –±–∞–∑—É");
                }
            }, 1000);
        }

        function cancelRecall() {
            state_recalling = false;
            clearInterval(recall_clock);
            document.getElementById('ui-message').style.display = 'none';
            recall_fx.material.opacity = 0;
        }

        /**
         * –ú–ò–ù–ò–ö–ê–†–¢–ê
         */
        function updateMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 220; canvas.height = 220;

            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, 220, 220);

            map_obstacles.forEach(o => {
                if(o.deco) return;
                ctx.fillStyle = o.team === 'blue' ? TEAM_BLUE : TEAM_RED;
                const mx = ((o.x + WORLD_DIM/2) / WORLD_DIM) * 220;
                const mz = ((o.z + WORLD_DIM/2) / WORLD_DIM) * 220;
                const s = o.throne ? 10 : 5;
                ctx.fillRect(mx-s/2, mz-s/2, s, s);
            });

            ctx.fillStyle = '#fff';
            const px = ((hero_unit.position.x + WORLD_DIM/2) / WORLD_DIM) * 220;
            const pz = ((hero_unit.position.z + WORLD_DIM/2) / WORLD_DIM) * 220;
            ctx.beginPath();
            ctx.arc(px, pz, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        /**
         * –ò–ì–†–û–í–û–ô –¶–ò–ö–õ
         */
        function coreLoop() {
            requestAnimationFrame(coreLoop);
            
            if (input_moving && !state_recalling) {
                const speed = 0.5;
                const nx = hero_unit.position.x + input_vector.x * speed;
                const nz = hero_unit.position.z + input_vector.z * speed;
                
                let collision = false;
                map_obstacles.forEach(o => {
                    const dist = Math.sqrt((nx - o.x)**2 + (nz - o.z)**2);
                    if (dist < o.r + 2) collision = true;
                });

                if (!collision && Math.abs(nx) < WORLD_DIM/2 && Math.abs(nz) < WORLD_DIM/2) {
                    hero_unit.position.set(nx, 0, nz);
                }
                hero_unit.rotation.y = Math.atan2(-input_vector.x, -input_vector.z);
            }

            if(state_recalling) recall_fx.rotation.y += 0.2;

            view_offset.x *= 0.9;
            view_offset.z *= 0.9;
            engine_camera.position.set(hero_unit.position.x + view_offset.x, 45, hero_unit.position.z + 40 + view_offset.z);
            engine_camera.lookAt(hero_unit.position.x + view_offset.x, 0, hero_unit.position.z + view_offset.z);

            updateMinimap();
            engine_renderer.render(engine_scene, engine_camera);
        }

        window.addEventListener('resize', () => {
            engine_camera.aspect = window.innerWidth / window.innerHeight;
            engine_camera.updateProjectionMatrix();
            engine_renderer.setSize(window.innerWidt
