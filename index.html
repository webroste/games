<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Chaos Arena v27: Final Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; color: #00ffff; user-select: none; }
        
        #menu { position: fixed; inset: 0; background: radial-gradient(circle at 50% 50%, #0a1a2a 0%, #000 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; border: 10px solid #001a1a; }
        .menu-title { font-size: 60px; letter-spacing: 10px; text-shadow: 0 0 20px #00ffff; margin-bottom: 30px; }
        
        .row { display: flex; gap: 15px; margin-bottom: 20px; }
        .btn { background: rgba(0,40,40,0.5); color: #00ffff; border: 2px solid #00ffff; padding: 15px 25px; font-size: 16px; cursor: pointer; transition: 0.2s; font-weight: bold; min-width: 160px; text-align: center; }
        .btn:hover { background: rgba(0,255,255,0.2); box-shadow: 0 0 15px #00ffff; }
        .btn.selected { background: #00ffff !important; color: #000 !important; }
        
        #ui { position: fixed; inset: 0; pointer-events: none; z-index: 10; display: none; }
        #hp-bar { width: 300px; height: 20px; background: #300; border: 2px solid #00ffff; position: absolute; bottom: 40px; left: 40px; }
        #hp-fill { width: 100%; height: 100%; background: #00ffff; }
        #class-display { position: absolute; bottom: 70px; left: 40px; font-size: 18px; text-transform: uppercase; }
        #minimap { position: absolute; top: 20px; left: 20px; width: 180px; height: 180px; background: rgba(0,0,0,0.8); border: 2px solid #00ffff; border-radius: 50%; overflow: hidden; }
        #map-canvas { width: 100%; height: 100%; }
        .nickname { position: absolute; font-weight: bold; font-size: 12px; text-shadow: 1px 1px 2px black; pointer-events: none; color: white; }
    </style>
</head>
<body>

<div id="menu">
    <div class="menu-title">CHAOS ARENA</div>
    
    <div class="row" id="modes-row">
        <div class="btn selected" onclick="setMode(this, 1)">SOLO</div>
        <div class="btn" onclick="setMode(this, 2)">DUO</div>
        <div class="btn" onclick="setMode(this, 4)">SQUAD</div>
    </div>

    <div class="row" id="heroes-row">
        <div class="btn selected" onclick="setHero(this, 'SOLDIER')">SOLDIER</div>
        <div class="btn" onclick="setHero(this, 'TANK')">TANK</div>
        <div class="btn" onclick="setHero(this, 'ASSASSIN')">ASSASSIN</div>
    </div>

    <div class="btn" onclick="startGame()" style="margin-top: 30px; border-color: #ff00ff; color: #ff00ff; font-size: 24px;">START GAME</div>
</div>

<div id="ui">
    <div id="minimap"><canvas id="map-canvas"></canvas></div>
    <div id="hp-bar"><div id="hp-fill"></div></div>
    <div id="class-display">CLASS: <span id="ui-hero-name">SOLDIER</span></div>
    <div style="position: absolute; top: 20px; right: 20px; font-size: 24px;">ALIVE: <span id="ui-alive">0</span></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
let scene, camera, renderer, player, clock, mapCtx;
let gameActive = false, entities = [], bullets = [], buildings = [], missiles = [];
let keys = {}, score = 0, zoneRadius = 280;
let currentMode = 1, currentHero = 'SOLDIER';

const HERO_DATA = {
    'SOLDIER':  { hp: 200, speed: 0.5, dmg: 1.0, color: 0x00ffff, size: 1.7 },
    'TANK':     { hp: 400, speed: 0.35, dmg: 0.7, color: 0x55ff55, size: 2.3 },
    'ASSASSIN': { hp: 120, speed: 0.75, dmg: 1.4, color: 0xaa00ff, size: 1.4 }
};

function setMode(el, m) {
    document.querySelectorAll('#modes-row .btn').forEach(b => b.classList.remove('selected'));
    el.classList.add('selected'); currentMode = m;
}

function setHero(el, h) {
    document.querySelectorAll('#heroes-row .btn').forEach(b => b.classList.remove('selected'));
    el.classList.add('selected'); currentHero = h;
}

function startGame() {
    document.getElementById('menu').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    document.getElementById('ui-hero-name').innerText = currentHero;
    init();
}

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x02050a);
    clock = new THREE.Clock();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Сетка пола
    const grid = new THREE.GridHelper(1000, 50, 0x00ffff, 0x002222);
    scene.add(grid);
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    // Здания
    for (let i = 0; i < 40; i++) {
        let h = 20 + Math.random()*30;
        const b = new THREE.Mesh(new THREE.BoxGeometry(15, h, 15), new THREE.MeshStandardMaterial({ color: 0x111111, emissive: 0x00ffff, emissiveIntensity: 0.05 }));
        b.position.set((Math.random()-0.5)*400, h/2, (Math.random()-0.5)*400);
        b.userData.box = new THREE.Box3().setFromObject(b);
        scene.add(b); buildings.push(b);
    }

    // Игрок
    player = spawnUnit(currentHero, 0, "YOU", true);
    entities.push(player);

    // Боты
    for (let i = 1; i < 30; i++) {
        let team = Math.floor(i / currentMode);
        if (currentMode > 1 && i < currentMode) team = 0;
        const types = Object.keys(HERO_DATA);
        const bot = spawnUnit(types[Math.floor(Math.random()*3)], team, team === 0 ? "ALLY" : "ENEMY", false);
        entities.push(bot);
    }

    window.onkeydown = (e) => keys[e.code] = true;
    window.onkeyup = (e) => keys[e.code] = false;
    
    // Самолет каждые 15 сек
    setInterval(launchPlane, 15000);
    
    gameActive = true; animate();
}

function getSafePos() {
    for(let i=0; i<30; i++) {
        let x = (Math.random()-0.5)*380, z = (Math.random()-0.5)*380;
        let testBox = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(x, 2, z), new THREE.Vector3(5, 5, 5));
        let collision = false;
        for(let b of buildings) if(testBox.intersectsBox(b.userData.box)) { collision = true; break; }
        if(!collision) return new THREE.Vector3(x, 0, z);
    }
    return new THREE.Vector3(0, 0, 0); // Если не нашли, то в центр
}

function spawnUnit(type, team, name, isPlayer) {
    const data = HERO_DATA[type];
    const group = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(data.size, data.size*2, data.size), new THREE.MeshStandardMaterial({ color: data.color }));
    body.position.y = data.size; group.add(body);
    
    const label = document.createElement('div'); label.className = 'nickname';
    label.style.color = team === 0 ? "#00ffff" : "#ff4444";
    document.body.appendChild(label);
    
    group.position.copy(getSafePos());
    scene.add(group);
    
    return { mesh: group, hp: data.hp, maxHp: data.hp, speed: data.speed, dmg: data.dmg, team, name, label, type, lastShot: 0, isPlayer, invuln: false };
}

function launchPlane() {
    const x = (Math.random()-0.5)*300, z = (Math.random()-0.5)*300;
    const marker = new THREE.Mesh(new THREE.RingGeometry(1, 15, 32), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5, side: THREE.DoubleSide }));
    marker.rotation.x = -Math.PI/2; marker.position.set(x, 0.2, z); scene.add(marker);
    
    setTimeout(() => {
        const missile = new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        missile.position.set(x, 100, z); scene.add(missile);
        missiles.push({ mesh: missile, target: new THREE.Vector3(x, 0, z), marker });
    }, 2000);
}

function animate() {
    if (!gameActive) return; requestAnimationFrame(animate);
    const now = Date.now();

    // Зона
    zoneRadius -= 0.02;

    // Классовые пассивки
    if(currentHero === 'ASSASSIN') {
        player.invuln = (now % 4500) > 3000;
        player.mesh.children[0].material.opacity = player.invuln ? 0.3 : 1.0;
        player.mesh.children[0].material.transparent = true;
    }

    // Ракеты
    for(let i=missiles.length-1; i>=0; i--) {
        const m = missiles[i];
        m.mesh.position.y -= 2;
        if(m.mesh.position.y <= 0) {
            entities.forEach(e => {
                if(e.mesh.position.distanceTo(m.target) < 15 && !e.invuln) e.hp -= 200;
            });
            scene.remove(m.mesh); scene.remove(m.marker); missiles.splice(i, 1);
        }
    }

    // Игроки и боты
    entities.forEach(ent => {
        const oldPos = ent.mesh.position.clone();
        if(ent.isPlayer) {
            if(keys['KeyW']) ent.mesh.translateZ(ent.speed);
            if(keys['KeyS']) ent.mesh.translateZ(-ent.speed);
            if(keys['KeyA']) ent.mesh.rotation.y += 0.05;
            if(keys['KeyD']) ent.mesh.rotation.y -= 0.05;
            if(keys['Space'] && now - ent.lastShot > 250) { fire(ent); ent.lastShot = now; }
        } else {
            let target = null, dMin = 150;
            entities.forEach(other => { if(other.team !== ent.team && other.hp > 0) {
                let d = ent.mesh.position.distanceTo(other.mesh.position);
                if(d < dMin) { dMin = d; target = other; }
            }});
            if(target) {
                ent.mesh.lookAt(target.mesh.position);
                if(dMin > 10) ent.mesh.translateZ(ent.speed);
                if(now - ent.lastShot > 600 && dMin < 60) { fire(ent); ent.lastShot = now; }
            }
        }
        
        // Коллизии
        let box = new THREE.Box3().setFromCenterAndSize(ent.mesh.position, new THREE.Vector3(3, 4, 3));
        for(let b of buildings) if(box.intersectsBox(b.userData.box)) { ent.mesh.position.copy(oldPos); break; }
        if(ent.mesh.position.length() > zoneRadius) ent.hp -= 0.3;
    });

    // Пули
    for(let i=bullets.length-1; i>=0; i--) {
        const b = bullets[i];
        b.mesh.position.add(b.dir.clone().multiplyScalar(3));
        let hit = false;
        entities.forEach(e => {
            if(e.team !== b.owner.team && !e.invuln && b.mesh.position.distanceTo(e.mesh.position) < 3) {
                e.hp -= 20 * b.owner.dmg; hit = true;
            }
        });
        if(hit || b.mesh.position.length() > 600) { scene.remove(b.mesh); bullets.splice(i, 1); }
    }

    // Смерть
    for(let i=entities.length-1; i>=0; i--) {
        if(entities[i].hp <= 0) {
            if(entities[i].isPlayer) { alert("DEAD. SCORE: " + score); location.reload(); }
            entities[i].label.remove(); scene.remove(entities[i].mesh); entities.splice(i, 1);
            if(!entities[i].isPlayer && entities[i].team !== 0) score++;
        }
    }

    // UI и Камера
    updateUI();
    camera.position.lerp(new THREE.Vector3(player.mesh.position.x, 70, player.mesh.position.z + 50), 0.1);
    camera.lookAt(player.mesh.position);
    renderer.render(scene, camera);
}

function fire(owner) {
    const bMesh = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: owner.isPlayer ? 0x00ffff : 0xff0000 }));
    bMesh.position.copy(owner.mesh.position).add(new THREE.Vector3(0, 2, 0));
    const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(owner.mesh.quaternion);
    bullets.push({ mesh: bMesh, dir, owner }); scene.add(bMesh);
}

function updateUI() {
    entities.forEach(e => {
        const v = e.mesh.position.clone().add(new THREE.Vector3(0, 5, 0)).project(camera);
        e.label.style.left = `${(v.x * 0.5 + 0.5) * window.innerWidth}px`;
        e.label.style.top = `${(-(v.y * 0.5 - 0.5) * window.innerHeight)}px`;
        e.label.innerHTML = `${e.name} [${Math.ceil(e.hp)}]`;
    });
    document.getElementById('hp-fill').style.width = (player.hp/player.maxHp*100) + "%";
    document.getElementById('ui-alive').innerText = entities.length;
    
    // Миникарта
    mapCtx.clearRect(0,0,180,180);
    entities.forEach(e => {
        mapCtx.fillStyle = e.isPlayer ? "#fff" : (e.team === 0 ? "#0f0" : "#f00");
        let mx = 90 + (e.mesh.position.x - player.mesh.position.x) * 0.3;
        let my = 90 + (e.mesh.position.z - player.mesh.position.z) * 0.3;
        mapCtx.fillRect(mx, my, 4, 4);
    });
}
</script>
</body>
</html>
