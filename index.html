<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Chaos Arena v30.4</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; color: #00ffff; user-select: none; }
        #menu { position: fixed; inset: 0; background: radial-gradient(circle at 15% 50%, #051a2a 0%, #000 100%); display: flex; flex-direction: column; align-items: flex-start; justify-content: center; padding-left: 80px; z-index: 2000; }
        .menu-title { font-size: 50px; letter-spacing: 10px; text-shadow: 0 0 25px #00ffff; margin-bottom: 40px; }
        .btn-list { display: flex; flex-direction: column; gap: 15px; }
        .btn { background: rgba(0,20,30,0.8); color: #008888; border: 2px solid #004444; padding: 15px 40px; font-size: 18px; cursor: pointer; transition: 0.3s; text-align: left; min-width: 250px; clip-path: polygon(0% 0%, 90% 0%, 100% 100%, 0% 100%); }
        .btn:hover { color: #00ffff; border-color: #00ffff; transform: translateX(10px); }
        .btn.selected { background: #00ffff !important; color: #000 !important; border-color: #00ffff; box-shadow: 0 0 30px #00ffff; }
        #ui { position: fixed; inset: 0; pointer-events: none; z-index: 10; display: none; }
        #hp-bar { width: 350px; height: 12px; background: rgba(255,0,0,0.1); border: 2px solid #00ffff; position: absolute; bottom: 40px; left: 40px; transform: skewX(-25deg); }
        #hp-fill { width: 100%; height: 100%; background: #00ffff; box-shadow: 0 0 15px #00ffff; }
        #minimap { position: absolute; top: 30px; left: 30px; width: 160px; height: 160px; background: rgba(0,5,10,0.9); border: 2px solid #00ffff; }
        #map-canvas { width: 100%; height: 100%; }
        #version { position: fixed; bottom: 15px; right: 20px; font-size: 12px; color: #00ffff; opacity: 0.5; }
        #stats { position: absolute; top: 30px; right: 40px; text-align: right; font-size: 20px; }
        #game-over { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 3000; border: 4px solid #ff0000; }
        #death-score { font-size: 40px; color: #ff0000; margin-bottom: 20px; text-shadow: 0 0 20px #ff0000; }
        .nickname { position: absolute; font-size: 12px; font-weight: bold; text-shadow: 1px 1px 2px #000; pointer-events: none; transform: translate(-50%, -120%); }
    </style>
</head>
<body>

<div id="menu">
    <div class="menu-title">CHAOS ARENA</div>
    <div class="btn-list">
        <div id="btn-SOLDIER" class="btn selected" onclick="pickHero('SOLDIER')">UNIT: SOLDIER</div>
        <div id="btn-TANK" class="btn" onclick="pickHero('TANK')">UNIT: TANK</div>
        <div id="btn-ASSASSIN" class="btn" onclick="pickHero('ASSASSIN')">UNIT: ASSASSIN</div>
        <div class="btn" onclick="initGame()" style="margin-top: 30px; color: #00ff00; border-color: #00ff00;">DEPLOY NOW</div>
    </div>
</div>

<div id="game-over">
    <div id="death-score">MISSION FAILED</div>
    <div style="font-size: 20px; margin-bottom: 30px;">SCORE: <span id="final-kills">0</span></div>
    <div class="btn" onclick="location.reload()" style="text-align: center; border-color: #00ffff; color: #00ffff;">BACK TO MENU</div>
</div>

<div id="ui">
    <div id="minimap"><canvas id="map-canvas" width="160" height="160"></canvas></div>
    <div id="hp-bar"><div id="hp-fill"></div></div>
    <div id="stats">KILLS: <span id="val-k">0</span> | ALIVE: <span id="val-a">0</span><br><span id="skill-hint" style="font-size:14px;color:#aaa">Q/E - SKILLS</span></div>
    <div id="version">BUILD v30.4 // FREE_FOR_ALL</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
let scene, camera, renderer, player, clock, mapCtx;
let gameRunning = false, entities = [], bullets = [], buildings = [], loot = [];
let keys = {}, mouse = { x: 0, y: 0 }, isFiring = false;
let score = 0, zoneRad = 400;
let selHero = 'SOLDIER';

const HERO_DATA = {
    'SOLDIER':  { hp: 200, spd: 0.6, color: 0x00ffff, size: 2.0 },
    'TANK':     { hp: 500, spd: 0.38, color: 0x55ff88, size: 3.0 },
    'ASSASSIN': { hp: 130, spd: 0.85, color: 0xff00ff, size: 1.6 }
};

function pickHero(type) {
    selHero = type;
    document.querySelectorAll('.btn').forEach(b => b.classList.remove('selected'));
    document.getElementById('btn-' + type).classList.add('selected');
}

function initGame() {
    document.getElementById('menu').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    mapCtx = document.getElementById('map-canvas').getContext('2d');
    
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x010408);
    clock = new THREE.Clock();
    
    camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 1, 1200);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const sun = new THREE.DirectionalLight(0xffffff, 0.6);
    sun.position.set(100, 200, 50);
    scene.add(sun);

    const grid = new THREE.GridHelper(1000, 50, 0x00ffff, 0x001a1a);
    scene.add(grid);

    zoneCyl = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 500, 64, 1, true), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.1, side: THREE.DoubleSide }));
    scene.add(zoneCyl);

    for (let i = 0; i < 35; i++) {
        let h = 30 + Math.random()*60;
        const b = new THREE.Mesh(new THREE.BoxGeometry(25, h, 25), new THREE.MeshStandardMaterial({ color: 0x151515 }));
        b.position.set((Math.random()-0.5)*650, h/2, (Math.random()-0.5)*650);
        b.userData.box = new THREE.Box3().setFromObject(b);
        scene.add(b); buildings.push(b);
    }

    player = spawnUnit(selHero, 0, "YOU", true);
    entities.push(player);

    for (let i = 0; i < 28; i++) {
        const t = Object.keys(HERO_DATA)[Math.floor(Math.random()*3)];
        entities.push(spawnUnit(t, i + 1, "UNIT_" + i, false)); // Разные команды для FFA
    }

    for(let i=0; i<15; i++) spawnMedkit();

    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    window.addEventListener('mousemove', e => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });
    window.addEventListener('mousedown', () => isFiring = true);
    window.addEventListener('mouseup', () => isFiring = false);
    
    gameRunning = true;
    update();
}

function spawnMedkit() {
    const m = new THREE.Mesh(new THREE.BoxGeometry(3,3,3), new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00 }));
    m.position.set((Math.random()-0.5)*600, 1.5, (Math.random()-0.5)*600);
    scene.add(m); loot.push(m);
}

function spawnUnit(type, team, name, isPlayer) {
    const d = HERO_DATA[type];
    const group = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(d.size, d.size*2, d.size), new THREE.MeshStandardMaterial({ color: d.color }));
    body.position.y = d.size;
    group.add(body);
    
    // Визуал щита (скрыт по умолчанию)
    const shield = new THREE.Mesh(new THREE.SphereGeometry(d.size * 2), new THREE.MeshBasicMaterial({ color: 0x55ff88, transparent: true, opacity: 0.3, wireframe: true }));
    shield.visible = false;
    group.add(shield);

    const label = document.createElement('div');
    label.className = 'nickname';
    label.style.color = isPlayer ? "#00ffff" : "#ff4444";
    document.body.appendChild(label);
    
    group.position.set((Math.random()-0.5)*600, 0, (Math.random()-0.5)*600);
    scene.add(group);
    
    return { mesh: group, body, shield, hp: d.hp, max: d.hp, spd: d.spd, team, label, type, isPlayer, lastShot: 0, cdSkill: 0, skillActive: false };
}

function update() {
    if (!gameRunning) return;
    requestAnimationFrame(update);
    const dt = clock.getDelta();
    const now = Date.now();

    zoneRad -= 0.06;
    zoneCyl.scale.set(zoneRad, 1, zoneRad);

    if(player.hp > 0) {
        const ray = new THREE.Raycaster();
        ray.setFromCamera(mouse, camera);
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const pt = new THREE.Vector3();
        if(ray.ray.intersectPlane(plane, pt)) player.mesh.lookAt(pt.x, 0, pt.z);

        const oldPos = player.mesh.position.clone();
        let moveVec = new THREE.Vector3(0,0,0);
        if (keys['KeyW']) moveVec.z -= 1; if (keys['KeyS']) moveVec.z += 1;
        if (keys['KeyA']) moveVec.x -= 1; if (keys['KeyD']) moveVec.x += 1;
        player.mesh.position.add(moveVec.normalize().multiplyScalar(player.spd));

        // Навыки игрока
        if(keys['KeyQ'] && player.type === 'ASSASSIN' && player.cdSkill <= 0) activateSkill(player);
        if(keys['KeyE'] && player.type === 'TANK' && player.cdSkill <= 0) activateSkill(player);
        
        if(player.skillActive && player.type === 'ASSASSIN') {
            player.mesh.translateZ(1.8);
            player.body.scale.set(0.6, 1, 2.0);
        } else if(!player.skillActive) {
            player.body.scale.set(1, 1, 1);
        }
        if(player.cdSkill > 0) player.cdSkill -= dt;

        if(isFiring && now - player.lastShot > 180) { shoot(player); player.lastShot = now; }

        let pBox = new THREE.Box3().setFromCenterAndSize(player.mesh.position, new THREE.Vector3(3, 5, 3));
        for (let b of buildings) if (pBox.intersectsBox(b.userData.box)) player.mesh.position.copy(oldPos);
    }

    // Логика ботов (FFA)
    entities.forEach(ent => {
        if(ent.isPlayer || ent.hp <= 0) return;

        let target = null;
        let minDist = 120;
        
        // Поиск ближайшей цели (игрок или другой бот)
        entities.forEach(other => {
            if(other !== ent && other.hp > 0 && other.team !== ent.team) {
                let d = ent.mesh.position.distanceTo(other.mesh.position);
                if(d < minDist) { minDist = d; target = other; }
            }
        });

        if(target) {
            ent.mesh.lookAt(target.mesh.position.x, 0, target.mesh.position.z);
            if(minDist > 25) ent.mesh.translateZ(ent.spd * 0.7);
            if(now - ent.lastShot > 1400) { shoot(ent); ent.lastShot = now; }
            
            // Использование навыков ботами
            if(ent.cdSkill <= 0) {
                if(ent.type === 'TANK' && ent.hp < ent.max * 0.5) activateSkill(ent);
                if(ent.type === 'ASSASSIN' && minDist < 40) activateSkill(ent);
            }
        }
        
        if(ent.skillActive && ent.type === 'ASSASSIN') ent.mesh.translateZ(1.2);
        if(ent.cdSkill > 0) ent.cdSkill -= dt;
        if (ent.mesh.position.length() > zoneRad) ent.hp -= 0.5;
    });

    // Пули
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.add(b.dir.clone().multiplyScalar(4.5));
        
        let hit = false;
        // Коллизия со зданиями (фикс пролета сквозь стены)
        for (let wall of buildings) {
            if (wall.userData.box.containsPoint(b.mesh.position)) { hit = true; break; }
        }

        if(!hit) {
            entities.forEach(e => {
                if(e.hp > 0 && e.team !== b.owner.team && b.mesh.position.distanceTo(e.mesh.position) < 4) {
                    let dmg = 35;
                    if(e.skillActive && e.type === 'TANK') dmg *= 0.2; // Щит танка
                    e.hp -= dmg; hit = true;
                    if(b.owner.isPlayer && e.hp <= 0) score++;
                }
            });
        }
        if(hit || b.mesh.position.length() > 1100) { scene.remove(b.mesh); bullets.splice(i, 1); }
    }

    // Подбор аптечек
    for(let i = loot.length - 1; i >= 0; i--) {
        if(player.mesh.position.distanceTo(loot[i].position) < 5) {
            player.hp = Math.min(player.max, player.hp + 60);
            scene.remove(loot[i]); loot.splice(i, 1);
        }
    }

    // Смерть
    for (let i = entities.length - 1; i >= 0; i--) {
        if (entities[i].hp <= 0) {
            if (entities[i].isPlayer) { showDeathScreen(); return; }
            entities[i].label.remove(); scene.remove(entities[i].mesh); entities.splice(i, 1);
        }
    }

    camera.position.set(player.mesh.position.x, 100, player.mesh.position.z + 65);
    camera.lookAt(player.mesh.position);
    updateUI();
    renderer.render(scene, camera);
}

function activateSkill(unit) {
    unit.skillActive = true;
    unit.cdSkill = 5.0; // Кулдаун 5 сек
    if(unit.type === 'TANK') unit.shield.visible = true;
    
    setTimeout(() => {
        unit.skillActive = false;
        if(unit.type === 'TANK') unit.shield.visible = false;
    }, unit.type === 'TANK' ? 3000 : 350); // Танк щит 3 сек, Ассасин рывок 0.35 сек
}

function showDeathScreen() {
    gameRunning = false;
    document.getElementById('ui').style.display = 'none';
    document.getElementById('game-over').style.display = 'flex';
    document.getElementById('final-kills').innerText = score;
}

function shoot(owner) {
    const b = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshBasicMaterial({ color: owner.isPlayer ? 0x00ffff : 0xff3300 }));
    b.position.copy(owner.mesh.position).add(new THREE.Vector3(0, 2.5, 0));
    const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(owner.mesh.quaternion);
    bullets.push({ mesh: b, dir, owner });
    scene.add(b);
}

function updateUI() {
    entities.forEach(e => {
        const v = e.mesh.position.clone().add(new THREE.Vector3(0, 6, 0)).project(camera);
        e.label.style.left = `${(v.x * 0.5 + 0.5) * window.innerWidth}px`;
        e.label.style.top = `${(-(v.y * 0.5 - 0.5) * window.innerHeight)}px`;
        e.label.innerText = e.hp > 0 ? (e.isPlayer ? "YOU" : "UNIT") : "";
    });
    document.getElementById('hp-fill').style.width = (player.hp / player.max * 100) + "%";
    document.getElementById('val-a').innerText = entities.length;
    document.getElementById('val-k').innerText = score;

    mapCtx.clearRect(0,0,160,160);
    entities.forEach(e => {
        mapCtx.fillStyle = e.isPlayer ? "#0ff" : "#f33";
        let mx = 80 + (e.mesh.position.x - player.mesh.position.x) * 0.25;
        let my = 80 + (e.mesh.position.z - player.mesh.position.z) * 0.25;
        mapCtx.fillRect(mx-2, my-2, 4, 4);
    });
}
</script>
</body>
</html>
